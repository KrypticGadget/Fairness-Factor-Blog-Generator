This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-11-02T10:36:20.693Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.env.example
.github/workflows/codeql.yml
.github/workflows/deploy.yml
.github/workflows/main.yml
.gitignore
.streamlit/config.toml
.streamlit/secrets.toml.example
app.py
config.py
Dockerfile
init_db.py
llm/__init__.py
llm/article_draft.py
llm/editing_criteria.py
llm/final_article.py
llm/image_description.py
llm/llm_client.py
llm/seo_generation.py
llm/topic_campaign.py
pages/__init__.py
pages/article_draft.py
pages/editing_criteria.py
pages/final_article.py
pages/image_description.py
pages/seo_generation.py
pages/topic_campaign.py
pages/topic_research.py
pages/user_management.py
Procfile
prompts/article_draft.txt
prompts/editing_criteria.txt
prompts/final_article.txt
prompts/image_description.txt
prompts/seo_generation.txt
prompts/topic_campaign.txt
prompts/topic_research.txt
README.md
requirements.txt
scripts/rotate_jwt_key.py
static/styles.css
test_auth.py
test_mongodb_connection.py
test_mongodb.py
tests/test_mongodb.py
utils/__init__.py
utils/auth_handler.py
utils/auth.py
utils/data_handlers.py
utils/key_rotation.py
utils/mongo_manager.py
utils/prompt_handler.py
utils/session_manager.py

================================================================
Repository Files
================================================================

================
File: .env.example
================
# Create a new .env.example file
cat > .env.example << EOL
# MongoDB Configuration
MONGODB_URI=mongodb+srv://<username>:<password>@<cluster>.mongodb.net/<database>?retryWrites=true&w=majority

# Authentication
JWT_SECRET_KEY=your_jwt_secret_key_here

# LLM API
ANTHROPIC_API_KEY=your_anthropic_api_key_here

# Application Settings
APP_NAME=Fairness Factor Blog Generator
APP_DOMAIN=fairnessfactor.com
ADMIN_EMAIL=admin@fairnessfactor.com
ADMIN_PASSWORD=your_secure_admin_password
EOL

# Ensure .env is in .gitignore
echo ".env" >> .gitignore

================
File: .github/workflows/codeql.yml
================
# .github/workflows/codeql.yml
name: "CodeQL"

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  schedule:
    - cron: '30 1 * * 0'

jobs:
  analyze:
    name: Analyze
    runs-on: ubuntu-latest
    permissions:
      actions: read
      contents: read
      security-events: write

    strategy:
      fail-fast: false
      matrix:
        language: [ 'python' ]

    steps:
    - name: Checkout repository
      uses: actions/checkout@v2

    - name: Initialize CodeQL
      uses: github/codeql-action/init@v2
      with:
        languages: ${{ matrix.language }}

    - name: Perform CodeQL Analysis
      uses: github/codeql-action/analyze@v2

================
File: .github/workflows/deploy.yml
================
# .github/workflows/deploy.yml
name: Deploy to Streamlit Cloud

on:
  push:
    branches: [ main ]
  schedule:
    - cron: '0 0 1 * *'  # Monthly key rotation

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v2
    
    - name: Set up Python
      uses: actions/setup-python@v2
      with:
        python-version: '3.9'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    
    - name: Deploy to Streamlit Cloud
      env:
        STREAMLIT_CREDENTIALS: ${{ secrets.STREAMLIT_CREDENTIALS }}
        MONGODB_URI: ${{ secrets.MONGODB_URI }}
        JWT_SECRET_KEY: ${{ secrets.JWT_SECRET_KEY }}
        ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
      run: |
        streamlit run app.py &

================
File: .github/workflows/main.yml
================
# .github/workflows/main.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v2
    
    - name: Set up Python
      uses: actions/setup-python@v2
      with:
        python-version: '3.9'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-cov
    
    - name: Run tests with coverage
      env:
        MONGODB_URI: ${{ secrets.MONGODB_URI }}
        JWT_SECRET_KEY: ${{ secrets.JWT_SECRET_KEY }}
        ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
      run: |
        pytest --cov=./ --cov-report=xml
    
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v2
      with:
        file: ./coverage.xml
        fail_ci_if_error: true

  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v2
    
    - name: Deploy to Streamlit Cloud
      env:
        STREAMLIT_API_KEY: ${{ secrets.STREAMLIT_API_KEY }}
      run: |
        curl -X POST https://api.streamlit.io/v1/apps \
          -H "Authorization: Bearer $STREAMLIT_API_KEY" \
          -H "Content-Type: application/json" \
          -d '{
            "gitRepo": "'"$GITHUB_REPOSITORY"'",
            "gitBranch": "main",
            "mainModule": "app.py",
            "customDomain": "blog-generator.fairnessfactor.com"
          }'

================
File: .gitignore
================
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
venv/
ENV/

# Environment variables
.env
.env.local
.env.*.local
.streamlit/secrets.toml

# IDE configurations
.idea/
.vscode/
*.swp
*.swo

# Project-specific files
data/outputs/*
!data/outputs/.gitkeep
*MASTER_CONTENTS.md

# System files
.DS_Store
Thumbs.db

# Test coverage files
.coverage
coverage.xml
htmlcov/

# Logs
*.log

================
File: .streamlit/config.toml
================
# .streamlit/config.toml

[server]
port = 8501
enableCORS = true
enableXsrfProtection = true
address = "localhost"  # Changed from 0.0.0.0

[browser]
serverAddress = "localhost"  # Changed from 0.0.0.0
gatherUsageStats = false

[theme]
primaryColor = "#0077BD"
backgroundColor = "#00263E"
secondaryBackgroundColor = "#005587"
textColor = "#FFFFFF"
font = "sans serif"

[logger]
level = "info"
messageFormat = "%(asctime)s - %(name)s - %(levelname)s - %(message)s"

================
File: .streamlit/secrets.toml.example
================
# .streamlit/secrets.toml.example
[mongodb]
uri = "${MONGODB_URI}"

[jwt]
secret_key = "${JWT_SECRET_KEY}"

[anthropic]
api_key = "${ANTHROPIC_API_KEY}"

[app]
name = "Fairness Factor Blog Generator"
emoji = "‚öñÔ∏è"
domain = "fairnessfactor.com"

================
File: app.py
================
# app.py
import streamlit as st
import asyncio
import os
from datetime import datetime
import logging
from typing import Optional, Dict, Any
import base64
from config import Config
from utils.auth import AsyncAuthHandler
from utils.mongo_manager import ensure_event_loop, get_db_session
from utils.data_handlers import (
    AsyncBlogContentHandler,
    AsyncFileHandler, 
    AsyncAnalyticsHandler
)
from utils.prompt_handler import AsyncPromptHandler
from utils.session_manager import AsyncSessionManager
from llm.llm_client import get_llm_client

# Import page modules
from pages.topic_research import topic_research_page
from pages.topic_campaign import topic_campaign_page
from pages.article_draft import article_draft_page
from pages.editing_criteria import editing_criteria_page
from pages.final_article import final_article_page
from pages.image_description import image_description_page
from pages.seo_generation import seo_generation_page
from pages.user_management import user_management_page

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@st.cache_resource
def initialize_app():
    """Initialize application resources"""
    ensure_event_loop()
    return {
        'mongo_session': get_db_session(),
        'llm_client': get_llm_client()
    }

def init_session_state():
    """Initialize session state"""
    defaults = {
        'initialized': False,
        'authenticated': False,
        'user': None,
        'user_token': None,
        'session_id': None,
        'db_handlers': None,
        'auth_handler': None,
        'session_manager': None,
        'prompt_handler': None,
        'llm_client': None
    }
    
    for key, value in defaults.items():
        if key not in st.session_state:
            st.session_state[key] = value

async def setup_handlers():
    """Set up application handlers"""
    if not st.session_state.initialized:
        try:
            # Get app resources
            resources = initialize_app()
            
            # Initialize database connection
            async with resources['mongo_session'] as (client, db, fs):
                # Initialize handlers
                st.session_state.db_handlers = {
                    'blog': AsyncBlogContentHandler(db),
                    'file': AsyncFileHandler(fs),
                    'analytics': AsyncAnalyticsHandler(db)
                }
                st.session_state.auth_handler = AsyncAuthHandler(db)
                st.session_state.session_manager = AsyncSessionManager(db)
                st.session_state.prompt_handler = AsyncPromptHandler(db)
                st.session_state.llm_client = resources['llm_client']
                st.session_state.initialized = True
                
            logger.info("Application handlers initialized successfully")
            
        except Exception as e:
            logger.error(f"Failed to initialize handlers: {e}")
            raise

def load_css():
    """Load CSS styles"""
    with open('static/styles.css') as f:
        st.markdown(f'<style>{f.read()}</style>', unsafe_allow_html=True)

def display_logo():
    """Display logo"""
    logo_path = os.path.join('assets', 'FairnessFactorLogo.png')
    if os.path.exists(logo_path):
        st.image(logo_path)

async def handle_login(email: str, password: str) -> bool:
    """Process user login"""
    try:
        auth_handler = st.session_state.auth_handler
        
        # Verify email domain
        if not await auth_handler.verify_email_domain(email):
            st.error("Please use your Fairness Factor email address")
            return False

        # Login attempt
        token = await auth_handler.login(email, password)
        if token is None:
            return False

        # Get user info
        user_info = await auth_handler.verify_token(token)
        if user_info is None:
            return False

        # Set session state
        st.session_state.authenticated = True
        st.session_state.user = user_info
        st.session_state.user_token = token

        # Create session and log activity
        session_id = await st.session_state.session_manager.create_session(
            email,
            {'login_time': datetime.now().isoformat()}
        )
        st.session_state.session_id = session_id
        
        await st.session_state.db_handlers['analytics'].log_activity(
            email,
            'login',
            {'success': True, 'session_id': session_id}
        )

        return True

    except Exception as e:
        logger.error(f"Login error: {e}")
        return False

async def handle_logout():
    """Process user logout"""
    try:
        if st.session_state.session_id:
            await st.session_state.session_manager.end_session(
                st.session_state.session_id
            )
            
            if st.session_state.user:
                await st.session_state.db_handlers['analytics'].log_activity(
                    st.session_state.user['email'],
                    'logout',
                    {'session_id': st.session_state.session_id}
                )

        # Reset state but keep handlers
        for key in list(st.session_state.keys()):
            if key not in ['initialized', 'db_handlers', 'auth_handler', 
                          'session_manager', 'prompt_handler', 'llm_client']:
                del st.session_state[key]

    except Exception as e:
        logger.error(f"Logout error: {e}")

def login_page():
    """Display login page"""
    st.title("Fairness Factor Blog Generator")
    display_logo()
    
    with st.form("login_form"):
        email = st.text_input("Email", placeholder="example@fairnessfactor.com")
        password = st.text_input("Password", type="password")
        
        if st.form_submit_button("Sign In"):
            loop = asyncio.get_event_loop()
            if loop.run_until_complete(handle_login(email, password)):
                st.success("Login successful!")
                st.rerun()
            else:
                st.error("Invalid credentials")

def main_page():
    """Display main application page"""
    st.title("Fairness Factor Blog Generator")
    display_logo()
    
    # Sidebar navigation
    with st.sidebar:
        st.write(f"Welcome, {st.session_state.user['name']}")
        
        pages = [
            'Topic Research',
            'Topic Campaign',
            'Article Draft',
            'Editing Criteria',
            'Final Article',
            'Image Description',
            'SEO Generation'
        ]
        
        if st.session_state.user.get('role') == 'admin':
            pages.append('User Management')
        
        page = st.selectbox("Navigation", pages)
        
        if st.button("Sign Out"):
            loop = asyncio.get_event_loop()
            loop.run_until_complete(handle_logout())
            st.rerun()
    
    # Page routing
    try:
        loop = asyncio.get_event_loop()
        
        if page == "User Management" and st.session_state.user.get('role') == 'admin':
            loop.run_until_complete(
                user_management_page(
                    st.session_state.db_handlers,
                    st.session_state.auth_handler
                )
            )
        elif page == "Topic Research":
            loop.run_until_complete(
                topic_research_page(
                    st.session_state.db_handlers,
                    st.session_state.llm_client,
                    st.session_state.prompt_handler
                )
            )
        elif page == "Topic Campaign":
            loop.run_until_complete(
                topic_campaign_page(
                    st.session_state.db_handlers,
                    st.session_state.llm_client,
                    st.session_state.prompt_handler
                )
            )
        elif page == "Article Draft":
            loop.run_until_complete(
                article_draft_page(
                    st.session_state.db_handlers,
                    st.session_state.llm_client,
                    st.session_state.prompt_handler
                )
            )
        elif page == "Editing Criteria":
            loop.run_until_complete(
                editing_criteria_page(
                    st.session_state.db_handlers,
                    st.session_state.llm_client,
                    st.session_state.prompt_handler
                )
            )
        elif page == "Final Article":
            loop.run_until_complete(
                final_article_page(
                    st.session_state.db_handlers,
                    st.session_state.llm_client,
                    st.session_state.prompt_handler
                )
            )
        elif page == "Image Description":
            loop.run_until_complete(
                image_description_page(
                    st.session_state.db_handlers,
                    st.session_state.llm_client,
                    st.session_state.prompt_handler
                )
            )
        elif page == "SEO Generation":
            loop.run_until_complete(
                seo_generation_page(
                    st.session_state.db_handlers,
                    st.session_state.llm_client,
                    st.session_state.prompt_handler
                )
            )
            
    except Exception as e:
        logger.error(f"Page error: {e}")
        st.error("An error occurred loading the page")

def main():
    """Main application entry point"""
    try:
        # Initialize session state
        init_session_state()

        # Configure page
        st.set_page_config(
            page_title="Fairness Factor Blog Generator",
            page_icon="‚öñÔ∏è",
            layout="wide",
            initial_sidebar_state="expanded"
        )

        # Load CSS
        load_css()

        # Ensure event loop exists
        ensure_event_loop()

        # Initialize handlers if needed
        if not st.session_state.initialized:
            loop = asyncio.get_event_loop()
            loop.run_until_complete(setup_handlers())

        # Render appropriate page
        if not st.session_state.authenticated:
            login_page()
        else:
            main_page()

    except Exception as e:
        logger.error(f"Application error: {e}")
        st.error("An unexpected error occurred")

if __name__ == "__main__":
    main()

================
File: config.py
================
# E:\Kryptic Gadget Github Repos\Fairness-Factor-Blog-Generator\config.py
import streamlit as st
import os
from typing import Optional
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

def get_secret(key: str) -> Optional[str]:
    """Get secret from Streamlit secrets or environment variables"""
    try:
        # Try Streamlit secrets first
        return st.secrets[key]
    except:
        # Fall back to environment variables
        return os.getenv(key)

class Config:
    MONGODB_URI = get_secret("MONGODB_URI")
    JWT_SECRET_KEY = get_secret("JWT_SECRET_KEY")
    ANTHROPIC_API_KEY = get_secret("ANTHROPIC_API_KEY")
    
    @classmethod
    def validate(cls):
        """Validate all required configuration is present"""
        missing = []
        for attr in ['MONGODB_URI', 'JWT_SECRET_KEY', 'ANTHROPIC_API_KEY']:
            if not getattr(cls, attr):
                missing.append(attr)
        if missing:
            raise ValueError(f"Missing required configuration: {', '.join(missing)}")

================
File: Dockerfile
================
# Dockerfile
FROM python:3.9-slim

WORKDIR /app

# Install system dependencies
COPY packages.txt .
RUN apt-get update && cat packages.txt | xargs apt-get install -y

# Install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Expose Streamlit port
EXPOSE 8501

# Health check
HEALTHCHECK CMD curl --fail http://localhost:8501/_stcore/health

# Run the application
ENTRYPOINT ["streamlit", "run", "app.py", "--server.port=8501", "--server.address=0.0.0.0"]

================
File: init_db.py
================
import asyncio
from motor.motor_asyncio import AsyncIOMotorClient
from datetime import datetime
import bcrypt
import logging
from typing import List, Dict

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

async def init_collections(uri: str):
    """Initialize database collections with required indexes"""
    try:
        client = AsyncIOMotorClient(uri)
        db = client.fairness_factor_blog
        
        # Required collections
        collections = {
            'users': [
                [('email', 1)],  # Unique index on email
                [('created_at', -1)]
            ],
            'blog_content': [
                [('user_email', 1)],
                [('type', 1)],
                [('created_at', -1)]
            ],
            'analytics': [
                [('user_email', 1)],
                [('activity_type', 1)],
                [('timestamp', -1)]
            ],
            'sessions': [
                [('user_email', 1)],
                [('active', 1)],
                [('created_at', -1)]
            ],
            'jwt_keys': [
                [('created_at', -1)],
                [('is_active', 1)]
            ]
        }
        
        # Create collections and indexes
        for coll_name, indexes in collections.items():
            logger.info(f"Setting up collection: {coll_name}")
            
            # Create collection if it doesn't exist
            if coll_name not in await db.list_collection_names():
                await db.create_collection(coll_name)
            
            # Create indexes
            for index in indexes:
                await db[coll_name].create_index(index)
        
        # Create default admin user if not exists
        admin_email = 'zack@fairnessfactor.com'
        if not await db.users.find_one({'email': admin_email}):
            salt = bcrypt.gensalt()
            password = "1122Kryptic$"  # Change this in production!
            hashed = bcrypt.hashpw(password.encode('utf-8'), salt)
            
            await db.users.insert_one({
                'email': admin_email,
                'password': hashed,
                'name': 'Admin User',
                'role': 'admin',
                'created_at': datetime.now(),
                'created_by': 'system'
            })
            logger.info("Created default admin user")
        
        logger.info("‚úÖ Database initialization complete!")
        return True
        
    except Exception as e:
        logger.error(f"‚ùå Database initialization failed: {str(e)}")
        return False
        
    finally:
        client.close()

if __name__ == "__main__":
    # Get MongoDB URI from environment or use default
    from dotenv import load_dotenv
    import os
    
    load_dotenv()
    uri = os.getenv('MONGODB_URI')
    
    if not uri:
        logger.error("MongoDB URI not found in environment variables")
        exit(1)
    
    asyncio.run(init_collections(uri))

================
File: llm/__init__.py
================
from .llm_client import AsyncLLMClient
from .topic_campaign import generate_topic_campaign
from .article_draft import generate_article_draft
from .editing_criteria import generate_editing_suggestions
from .final_article import generate_final_article
from .image_description import generate_image_description
from .seo_generation import generate_seo_content

__all__ = [
    'AsyncLLMClient',
    'generate_topic_campaign',
    'generate_article_draft',
    'generate_editing_suggestions',
    'generate_final_article',
    'generate_image_description',
    'generate_seo_content'
]

================
File: llm/article_draft.py
================
import logging
from typing import Dict, Any, Optional

logger = logging.getLogger(__name__)

async def generate_article_draft(
    topic: str,
    structure: str,
    llm_client: Any,
    prompt_handler: Any,
    user_email: str
) -> Optional[Dict[str, Any]]:
    """Generate article draft based on selected topic and structure"""
    try:
        draft_prompt = await prompt_handler.format_prompt(
            'article_draft',
            {
                'selected_topic': topic,
                'article_structure': structure
            }
        )
        
        if not draft_prompt:
            raise ValueError("Failed to format draft prompt")

        draft_content = await llm_client.generate_response(
            system_prompt="You are an AI writer creating blog articles for Fairness Factor...",
            user_prompt=draft_prompt,
            max_tokens=2000,
            user_email=user_email
        )
        
        return {
            'success': True,
            'draft': draft_content
        }
    except Exception as e:
        logger.error(f"Error generating article draft: {str(e)}")
        return {
            'success': False,
            'error': str(e)
        }

================
File: llm/editing_criteria.py
================
import logging
from typing import Dict, Any, Optional

logger = logging.getLogger(__name__)

async def generate_editing_suggestions(
    draft: str,
    criteria: Dict[str, str],
    llm_client: Any,
    prompt_handler: Any,
    user_email: str
) -> Optional[Dict[str, Any]]:
    """Generate editing suggestions based on provided criteria"""
    try:
        editing_prompt = await prompt_handler.format_prompt(
            'editing_criteria',
            {
                'article_draft': draft,
                'editing_criteria': '\n'.join(f"{k}: {v}" for k, v in criteria.items())
            }
        )
        
        if not editing_prompt:
            raise ValueError("Failed to format editing prompt")

        suggestions = await llm_client.generate_response(
            system_prompt="You are an AI editor reviewing Fairness Factor blog articles...",
            user_prompt=editing_prompt,
            max_tokens=1500,
            user_email=user_email
        )
        
        return {
            'success': True,
            'suggestions': suggestions
        }
    except Exception as e:
        logger.error(f"Error generating editing suggestions: {str(e)}")
        return {
            'success': False,
            'error': str(e)
        }

================
File: llm/final_article.py
================
import logging
from typing import Dict, Any, Optional

logger = logging.getLogger(__name__)

async def generate_final_article(
    draft: str,
    suggestions: str,
    feedback: str,
    llm_client: Any,
    prompt_handler: Any,
    user_email: str
) -> Optional[Dict[str, Any]]:
    """Generate final article incorporating editing suggestions and feedback"""
    try:
        final_prompt = await prompt_handler.format_prompt(
            'final_article',
            {
                'article_draft': draft,
                'editing_suggestions': suggestions,
                'user_feedback': feedback
            }
        )
        
        if not final_prompt:
            raise ValueError("Failed to format final article prompt")

        final_content = await llm_client.generate_response(
            system_prompt="You are an AI editor finalizing Fairness Factor blog articles...",
            user_prompt=final_prompt,
            max_tokens=2000,
            user_email=user_email
        )
        
        return {
            'success': True,
            'article': final_content
        }
    except Exception as e:
        logger.error(f"Error generating final article: {str(e)}")
        return {
            'success': False,
            'error': str(e)
        }

================
File: llm/image_description.py
================
import logging
from typing import Dict, Any, Optional

logger = logging.getLogger(__name__)

async def generate_image_description(
    article: str,
    llm_client: Any,
    prompt_handler: Any,
    user_email: str
) -> Optional[Dict[str, Any]]:
    """Generate image description based on article content"""
    try:
        image_prompt = await prompt_handler.format_prompt(
            'image_description',
            {'final_article': article}
        )
        
        if not image_prompt:
            raise ValueError("Failed to format image description prompt")

        description = await llm_client.generate_response(
            system_prompt="You are an AI designer creating image descriptions for Fairness Factor blog articles...",
            user_prompt=image_prompt,
            max_tokens=500,
            user_email=user_email
        )
        
        return {
            'success': True,
            'description': description
        }
    except Exception as e:
        logger.error(f"Error generating image description: {str(e)}")
        return {
            'success': False,
            'error': str(e)
        }

================
File: llm/llm_client.py
================
# llm/llm_client.py
import os
import anthropic
import asyncio
from dotenv import load_dotenv
import logging
from typing import Optional, List, Dict
from datetime import datetime
from utils.mongo_manager import AsyncMongoManager, get_db_session, ensure_event_loop

load_dotenv()
logger = logging.getLogger(__name__)

class AsyncLLMClient:
    def __init__(self):
        api_key = os.getenv("ANTHROPIC_API_KEY")
        if api_key is None:
            raise ValueError("ANTHROPIC_API_KEY not found in environment variables")
            
        # Initialize Anthropic client
        ensure_event_loop()  # Ensure event loop exists
        self.client = anthropic.AsyncAnthropic(api_key=api_key)

    async def log_llm_request(self, request_data: Dict) -> str:
        """Log LLM request to MongoDB"""
        async with get_db_session() as (_, db, _):
            result = await db.llm_logs.insert_one({
                **request_data,
                'timestamp': datetime.now()
            })
            return str(result.inserted_id)

    async def generate_response(
        self, 
        system_prompt: str, 
        user_prompt: str, 
        max_tokens: int = 1000,
        user_email: Optional[str] = None
    ) -> Optional[str]:
        try:
            logger.info("Sending prompt to LLM...")
            
            # Log request
            request_data = {
                'system_prompt': system_prompt,
                'user_prompt': user_prompt,
                'max_tokens': max_tokens,
                'user_email': user_email
            }
            log_id = await self.log_llm_request(request_data)
            
            # Generate response
            response = await self.client.messages.create(
                model="claude-3-opus-20240229",
                max_tokens=max_tokens,
                temperature=0.5,
                system=system_prompt,
                messages=[{
                    "role": "user",
                    "content": [{"type": "text", "text": user_prompt}]
                }]
            )
            
            result = response.content[0].text
            logger.info(f"LLM Response received for log_id: {log_id}")
            
            # Update log with response
            async with get_db_session() as (_, db, _):
                await db.llm_logs.update_one(
                    {'_id': log_id},
                    {'$set': {'response': result, 'completed_at': datetime.now()}}
                )
            
            return result
            
        except Exception as e:
            logger.error(f"LLM error: {str(e)}")
            if 'log_id' in locals():
                async with get_db_session() as (_, db, _):
                    await db.llm_logs.update_one(
                        {'_id': log_id},
                        {'$set': {'error': str(e), 'completed_at': datetime.now()}}
                    )
            return None

    async def generate_batch_responses(
        self, 
        prompts: List[Dict[str, str]], 
        user_email: Optional[str] = None
    ) -> List[Optional[str]]:
        """Generate multiple responses concurrently"""
        tasks = []
        for prompt in prompts:
            task = asyncio.create_task(
                self.generate_response(
                    prompt['system_prompt'],
                    prompt['user_prompt'],
                    prompt.get('max_tokens', 1000),
                    user_email
                )
            )
            tasks.append(task)
        
        return await asyncio.gather(*tasks)

# Create singleton instance
llm_client = None

def get_llm_client():
    """Get or create LLM client instance"""
    global llm_client
    if llm_client is None:
        llm_client = AsyncLLMClient()
    return llm_client

================
File: llm/seo_generation.py
================
import logging
from typing import Dict, Any, Optional

logger = logging.getLogger(__name__)

async def generate_seo_content(
    article: str,
    image_description: str,
    llm_client: Any,
    prompt_handler: Any,
    user_email: str
) -> Optional[Dict[str, Any]]:
    """Generate SEO content for the article"""
    try:
        seo_prompt = await prompt_handler.format_prompt(
            'seo_generation',
            {
                'final_article': article,
                'image_description': image_description
            }
        )
        
        if not seo_prompt:
            raise ValueError("Failed to format SEO prompt")

        seo_content = await llm_client.generate_response(
            system_prompt="You are an SEO expert optimizing Fairness Factor blog content...",
            user_prompt=seo_prompt,
            max_tokens=1000,
            user_email=user_email
        )
        
        return {
            'success': True,
            'seo_content': seo_content
        }
    except Exception as e:
        logger.error(f"Error generating SEO content: {str(e)}")
        return {
            'success': False,
            'error': str(e)
        }

================
File: llm/topic_campaign.py
================
# llm/topic_campaign.py
import logging
from typing import Dict, Any, Optional

logger = logging.getLogger(__name__)

async def generate_topic_campaign(
    research_analysis: str,
    llm_client: Any,
    prompt_handler: Any,
    user_email: str
) -> Optional[Dict[str, Any]]:
    """Generate topic campaign based on research analysis"""
    try:
        # Format campaign prompt
        campaign_prompt = await prompt_handler.format_prompt(
            'topic_campaign',
            {'research_analysis': research_analysis}
        )
        
        if not campaign_prompt:
            raise ValueError("Failed to format campaign prompt")

        # Generate campaign content
        campaign_content = await llm_client.generate_response(
            system_prompt="You are an AI strategist creating content campaigns for Fairness Factor...",
            user_prompt=campaign_prompt,
            max_tokens=1000,
            user_email=user_email
        )
        
        return {
            'success': True,
            'campaign': campaign_content
        }
    except Exception as e:
        logger.error(f"Error generating topic campaign: {str(e)}")
        return {
            'success': False,
            'error': str(e)
        }

================
File: pages/__init__.py
================
from .topic_research import topic_research_page
from .topic_campaign import topic_campaign_page
from .article_draft import article_draft_page
from .editing_criteria import editing_criteria_page
from .final_article import final_article_page
from .image_description import image_description_page
from .seo_generation import seo_generation_page

__all__ = [
    'topic_research_page',
    'topic_campaign_page',
    'article_draft_page',
    'editing_criteria_page',
    'final_article_page',
    'image_description_page',
    'seo_generation_page'
]

================
File: pages/article_draft.py
================
# pages/article_draft.py
import streamlit as st
import asyncio
from typing import Dict, Any, Optional
from llm.llm_client import AsyncLLMClient
from utils.prompt_handler import AsyncPromptHandler
import logging
import json
import yaml
from datetime import datetime

logger = logging.getLogger(__name__)

def check_page_access(page_name: str) -> bool:
    """Check if user has access to requested page"""
    if not st.session_state.authenticated:
        return False
        
    required_pages = {
        'Topic Research': ['user', 'admin'],
        'Topic Campaign': ['user', 'admin'],
        'Article Draft': ['user', 'admin'],
        'Editing Criteria': ['user', 'admin'],
        'Final Article': ['user', 'admin'],
        'Image Description': ['user', 'admin'],
        'SEO Generation': ['user', 'admin']
    }
    
    user_role = st.session_state.user.get('role', 'user')
    return user_role in required_pages.get(page_name, [])

logger = logging.getLogger(__name__)

class ArticleDraftGenerator:
    """Handles article draft generation and validation"""
    
    ARTICLE_TYPES = {
        "informative": "Educational content",
        "analytical": "In-depth analysis",
        "case_study": "Real-world examples",
        "how_to": "Practical guides"
    }
    
    DEFAULT_STRUCTURE = {
        "introduction": {
            "key_points": [
                "Hook the reader with a compelling opening",
                "Introduce the workplace issue or challenge",
                "Establish Fairness Factor's expertise"
            ]
        },
        "problem_statement": {
            "key_points": [
                "Define the workplace challenge",
                "Present relevant statistics or examples",
                "Explain impact on employees"
            ]
        },
        "solution": {
            "key_points": [
                "Introduce Fairness Factor's approach",
                "Highlight unique value proposition",
                "Explain methodology"
            ]
        },
        "benefits": {
            "employees": [
                "Improved workplace rights",
                "Better work environment",
                "Professional growth opportunities"
            ],
            "employers": [
                "Enhanced compliance",
                "Improved employee relations",
                "Reduced legal risks"
            ]
        },
        "case_study": {
            "elements": [
                "Real-world example",
                "Challenge faced",
                "Solution implemented",
                "Results achieved"
            ]
        },
        "conclusion": {
            "elements": [
                "Summarize key points",
                "Reinforce Fairness Factor's value",
                "Call to action"
            ]
        }
    }
    
    @staticmethod
    def validate_draft(draft: str) -> bool:
        """Validate article draft"""
        if not draft or len(draft.strip()) < 500:
            return False
        return True

async def generate_draft(
    topic: str,
    article_type: str,
    structure: Dict[str, Any],
    research_analysis: str,
    llm_client: AsyncLLMClient,
    prompt_handler: AsyncPromptHandler,
    user_email: str
) -> Dict[str, Any]:
    """Generate article draft asynchronously"""
    try:
        # Check user authentication
        if not user_email:
            raise ValueError("User not authenticated")

        # Format draft prompt
        draft_prompt = await prompt_handler.format_prompt(
            'article_draft',
            {
                'selected_topic': topic,
                'article_type': article_type,
                'article_structure': json.dumps(structure, indent=2),
                'research_analysis': research_analysis
            }
        )
        
        if not draft_prompt:
            raise ValueError("Failed to format draft prompt")

        # Generate draft
        draft = await llm_client.generate_response(
            system_prompt=(
                "You are an expert content writer for Fairness Factor, creating "
                f"engaging {article_type} articles about employee rights and workplace "
                "advocacy. Maintain a professional yet approachable tone, emphasizing "
                "Fairness Factor's expertise and commitment to employee advocacy."
            ),
            user_prompt=draft_prompt,
            max_tokens=2000,
            user_email=user_email
        )
        
        if not ArticleDraftGenerator.validate_draft(draft):
            raise ValueError("Generated draft does not meet minimum requirements")
        
        return {
            'success': True,
            'draft': draft
        }
    except Exception as e:
        logger.error(f"Error generating draft: {str(e)}")
        return {
            'success': False,
            'error': str(e)
        }

async def article_draft_page(db_handlers, llm_client, prompt_handler):
    """Article Draft Page Handler"""
    try:
        # Check authentication and access
        if not st.session_state.authenticated:
            st.warning("Please log in to access this page")
            st.stop()
            return
            
        if not check_page_access('Article Draft'):
            st.error("You don't have permission to access this page")
            st.stop()
            return

        user_email = st.session_state.user['email']
        
        # Check prerequisites
        if 'topic_campaign' not in st.session_state or 'selected_topic' not in st.session_state:
            st.warning("‚ö†Ô∏è Please complete the Topic Campaign step first")
            st.stop()
            return

        # Log page access
        await db_handlers['analytics'].log_activity(
            user_email=user_email,
            activity_type='page_access',
            metadata={'page': 'Article Draft'}
        )

        # Existing page code continues here...
        
        # Display previous content
        with st.expander("üìä Campaign Overview", expanded=False):
            st.write(st.session_state['topic_campaign'])
            st.write("### Selected Topic")
            st.write(st.session_state['selected_topic'])
        
        # Article settings
        st.write("### üìù Article Settings")
        
        col1, col2 = st.columns(2)
        
        with col1:
            article_type = st.selectbox(
                "Article Type:",
                list(ArticleDraftGenerator.ARTICLE_TYPES.keys()),
                format_func=lambda x: ArticleDraftGenerator.ARTICLE_TYPES[x],
                help="Select the type of article"
            )
            
            target_length = st.slider(
                "Target Word Count:",
                min_value=500,
                max_value=3000,
                value=1500,
                step=100,
                help="Select target article length"
            )
        
        with col2:
            tone_options = {
                "professional": "Formal and authoritative",
                "conversational": "Friendly and approachable",
                "balanced": "Professional yet accessible",
                "educational": "Instructive and informative"
            }
            
            tone = st.selectbox(
                "Writing Tone:",
                list(tone_options.keys()),
                format_func=lambda x: tone_options[x],
                help="Select the writing tone"
            )
            
            expertise_level = st.select_slider(
                "Expertise Level:",
                options=["Beginner", "Intermediate", "Advanced", "Expert"],
                value="Intermediate",
                help="Select content expertise level"
            )
        
        # Article structure editor
        st.write("### üìã Article Structure")
        
        # Load default or existing structure
        default_structure = ArticleDraftGenerator.DEFAULT_STRUCTURE
        current_structure = st.session_state.get('article_structure', default_structure)
        
        structure_json = st.text_area(
            "Edit article structure (JSON format):",
            value=json.dumps(current_structure, indent=2),
            height=300,
            help="Customize the article structure"
        )
        
        try:
            article_structure = json.loads(structure_json)
            st.session_state['article_structure'] = article_structure
        except json.JSONDecodeError:
            st.error("‚ùå Invalid JSON structure. Please check the format.")
            return
        
        # Generate draft
        if st.button("‚úçÔ∏è Generate Draft", help="Click to generate article draft"):
            with st.spinner("Generating article draft..."):
                try:
                    result = await generate_draft(
                        topic=st.session_state['selected_topic'],
                        article_type=article_type,
                        structure=article_structure,
                        research_analysis=st.session_state['research_analysis'],
                        llm_client=llm_client,
                        prompt_handler=prompt_handler,
                        user_email=user_email
                    )
                    
                    if result['success']:
                        # Save draft content
                        content_id = await db_handlers['blog'].save_content(
                            user_email=user_email,
                            content_type='draft',
                            content=result['draft'],
                            metadata={
                                'topic': st.session_state['selected_topic'],
                                'article_type': article_type,
                                'structure': article_structure,
                                'target_length': target_length,
                                'tone': tone,
                                'expertise_level': expertise_level,
                                'campaign_id': st.session_state.get('campaign_id'),
                                'research_id': st.session_state.get('research_id')
                            }
                        )
                        
                        # Update session state
                        st.session_state['article_draft'] = result['draft']
                        st.session_state['draft_id'] = content_id
                        
                        # Log activity
                        await db_handlers['analytics'].log_activity(
                            user_email=user_email,
                            activity_type='draft_generation',
                            metadata={
                                'content_id': content_id,
                                'article_type': article_type
                            }
                        )
                        
                        # Display draft
                        st.success("‚úÖ Draft generated successfully!")
                        
                        # Draft sections
                        st.write("### üìÑ Article Draft")
                        sections = result['draft'].split('\n\n')
                        
                        for i, section in enumerate(sections):
                            with st.expander(f"Section {i+1}", expanded=i==0):
                                st.write(section)
                                
                                # Section feedback
                                feedback = st.text_area(
                                    "Section Feedback:",
                                    key=f"feedback_{i}",
                                    help="Add notes or feedback for this section"
                                )
                                if feedback:
                                    st.session_state.setdefault('section_feedback', {})[i] = feedback
                        
                        # Draft actions
                        col1, col2, col3 = st.columns(3)
                        
                        with col1:
                            if st.button("üìù Edit Draft"):
                                st.session_state['editing_mode'] = True
                                st.experimental_rerun()
                        
                        with col2:
                            # Export as Markdown
                            if st.button("üì• Export as Markdown"):
                                markdown_content = f"""---
title: {st.session_state['selected_topic']}
author: {st.session_state.user['name']}
date: {datetime.now().strftime('%Y-%m-%d')}
type: {article_type}
expertise_level: {expertise_level}
---

{result['draft']}
"""
                                st.download_button(
                                    label="üíæ Download Markdown",
                                    data=markdown_content,
                                    file_name=f"draft_{content_id}.md",
                                    mime="text/markdown"
                                )
                        
                        with col3:
                            # Export as JSON
                            if st.button("üì§ Export as JSON"):
                                export_data = {
                                    'metadata': {
                                        'topic': st.session_state['selected_topic'],
                                        'author': st.session_state.user['name'],
                                        'date': datetime.now().isoformat(),
                                        'article_type': article_type,
                                        'tone': tone,
                                        'expertise_level': expertise_level
                                    },
                                    'structure': article_structure,
                                    'content': result['draft'],
                                    'feedback': st.session_state.get('section_feedback', {})
                                }
                                
                                st.download_button(
                                    label="üíæ Download JSON",
                                    data=json.dumps(export_data, indent=2),
                                    file_name=f"draft_{content_id}.json",
                                    mime="application/json"
                                )
                        
                    else:
                        st.error(f"‚ùå Draft generation failed: {result.get('error', 'Unknown error')}")
                        
                except Exception as e:
                    st.error(f"‚ùå An error occurred: {str(e)}")
                    logger.error(f"Error in draft generation: {str(e)}")
        
        # Draft history
        with st.expander("üìö Draft History", expanded=False):
            try:
                draft_history = await db_handlers['blog'].get_user_content(
                    user_email=user_email,
                    content_type='draft',
                    limit=5
                )
                
                if draft_history:
                    for entry in draft_history:
                        col1, col2, col3 = st.columns([3, 1, 1])
                        
                        with col1:
                            st.write(f"Draft: {entry['metadata'].get('topic', 'Untitled')}")
                            st.write(f"Created: {entry['created_at'].strftime('%Y-%m-%d %H:%M')}")
                            
                        with col2:
                            if st.button("Load", key=f"load_{entry['_id']}"):
                                st.session_state['article_draft'] = entry['content']
                                st.session_state['draft_id'] = str(entry['_id'])
                                st.experimental_rerun()
                                
                        with col3:
                            if st.button("Delete", key=f"delete_{entry['_id']}"):
                                try:
                                    await db_handlers['blog'].delete_content(str(entry['_id']))
                                    st.success("‚úÖ Draft deleted successfully!")
                                    st.experimental_rerun()
                                except Exception as e:
                                    st.error(f"‚ùå Error deleting draft: {str(e)}")
                        
                        st.markdown("---")
                else:
                    st.info("No previous drafts found.")
                    
            except Exception as e:
                st.error("Failed to load draft history")
                logger.error(f"Error loading draft history: {str(e)}")

        # Help section
        with st.expander("‚ùì Need Help?", expanded=False):
            st.markdown("""
            ### Writing Guidelines
            1. Start with a strong hook
            2. Use clear, concise language
            3. Include relevant examples
            4. Support claims with data
            5. Maintain consistent tone
            
            ### Structure Tips
            - Use short paragraphs
            - Include subheadings
            - Add transition sentences
            - End with clear CTA
            
            ### Best Practices
            - Research thoroughly
            - Write for your audience
            - Include expert insights
            - Proofread carefully
            
            ### Support
            Contact: content@fairnessfactor.com
            """)

    except Exception as e:
        logger.error(f"Error in article draft page: {str(e)}")
        st.error("An unexpected error occurred. Please try again.")

if __name__ == "__main__":
    # For testing the page individually
    import os
    from dotenv import load_dotenv
    
    load_dotenv()
    
    async def test_page():
        from utils.mongo_manager import AsyncMongoManager
        from utils.prompt_handler import AsyncPromptHandler
        from llm.llm_client import AsyncLLMClient
        
        mongo_manager = AsyncMongoManager()
        client, db = await mongo_manager.get_connection()
        
        handlers = {
            'blog': None,  # Add your handlers here
            'file': None,
            'analytics': None
        }
        
        await article_draft_page(
            handlers,
            AsyncLLMClient(),
            AsyncPromptHandler(db)
        )
    
    asyncio.run(test_page())

================
File: pages/editing_criteria.py
================
# pages/editing_criteria.py
import streamlit as st
import asyncio
from typing import Dict, Any, Optional
from llm.llm_client import AsyncLLMClient
from utils.prompt_handler import AsyncPromptHandler
import logging
import json
from datetime import datetime

logger = logging.getLogger(__name__)

def check_page_access(page_name: str) -> bool:
    """Check if user has access to requested page"""
    if not st.session_state.authenticated:
        return False
        
    required_pages = {
        'Topic Research': ['user', 'admin'],
        'Topic Campaign': ['user', 'admin'],
        'Article Draft': ['user', 'admin'],
        'Editing Criteria': ['user', 'admin'],
        'Final Article': ['user', 'admin'],
        'Image Description': ['user', 'admin'],
        'SEO Generation': ['user', 'admin']
    }
    
    user_role = st.session_state.user.get('role', 'user')
    return user_role in required_pages.get(page_name, [])

logger = logging.getLogger(__name__)

class EditingCriteria:
    """Editing criteria categories and defaults"""
    
    TONE_AND_VOICE = {
        "professional": "Maintain professional language while being approachable",
        "brand_voice": "Align with Fairness Factor's advocacy tone",
        "consistency": "Ensure consistent voice throughout the article",
        "engagement": "Keep readers engaged and interested"
    }
    
    CONTENT_QUALITY = {
        "accuracy": "Verify all facts and statistics",
        "clarity": "Ensure clear explanation of complex topics",
        "relevance": "Maintain focus on employee advocacy",
        "evidence": "Support claims with credible sources",
        "completeness": "Cover all essential aspects of the topic"
    }
    
    STRUCTURE = {
        "flow": "Ensure logical progression of ideas",
        "paragraphs": "Maintain appropriate paragraph length",
        "transitions": "Use smooth transitions between sections",
        "hierarchy": "Clear heading structure and organization"
    }
    
    SEO_OPTIMIZATION = {
        "keywords": "Include relevant keywords naturally",
        "readability": "Optimize for web reading",
        "headers": "Use proper header hierarchy",
        "meta_elements": "Optimize title and meta description"
    }
    
    LEGAL_COMPLIANCE = {
        "accuracy": "Ensure legal information is accurate",
        "disclaimers": "Include necessary disclaimers",
        "citations": "Properly cite legal sources",
        "currency": "Verify information is up-to-date"
    }

async def generate_editing_suggestions(
    draft: str,
    criteria: Dict[str, Dict[str, str]],
    section_feedback: Dict[int, str],
    llm_client: AsyncLLMClient,
    prompt_handler: AsyncPromptHandler,
    user_email: str
) -> Dict[str, Any]:
    """Generate editing suggestions based on criteria"""
    try:
        # Check user authentication
        if not user_email:
            raise ValueError("User not authenticated")

        # Format editing prompt
        editing_prompt = await prompt_handler.format_prompt(
            'editing_criteria',
            {
                'article_draft': draft,
                'editing_criteria': json.dumps(criteria, indent=2),
                'section_feedback': json.dumps(section_feedback, indent=2)
            }
        )
        
        if not editing_prompt:
            raise ValueError("Failed to format editing prompt")

        # Generate suggestions
        suggestions = await llm_client.generate_response(
            system_prompt=(
                "You are an expert editor for Fairness Factor, providing detailed "
                "suggestions to improve blog articles. Focus on maintaining professional "
                "tone while ensuring content is engaging and aligned with Fairness "
                "Factor's mission of employee advocacy."
            ),
            user_prompt=editing_prompt,
            max_tokens=2000,
            user_email=user_email
        )
        
        return {
            'success': True,
            'suggestions': suggestions
        }
    except Exception as e:
        logger.error(f"Error generating editing suggestions: {str(e)}")
        return {
            'success': False,
            'error': str(e)
        }

async def editing_criteria_page(db_handlers, llm_client, prompt_handler):
    """Editing Criteria Page Handler"""
    try:
        # Check authentication and access
        if not st.session_state.authenticated:
            st.warning("Please log in to access this page")
            st.stop()
            return
            
        if not check_page_access('Editing Criteria'):
            st.error("You don't have permission to access this page")
            st.stop()
            return

        user_email = st.session_state.user['email']
        
        # Check prerequisites
        if 'article_draft' not in st.session_state:
            st.warning("‚ö†Ô∏è Please complete the Article Draft step first")
            st.stop()
            return

        # Log page access
        await db_handlers['analytics'].log_activity(
            user_email=user_email,
            activity_type='page_access',
            metadata={'page': 'Editing Criteria'}
        )

        # Existing page code continues here...
        
        # Display draft
        with st.expander("üìÑ Article Draft", expanded=False):
            st.write(st.session_state['article_draft'])
        
        # Editing criteria sections
        st.write("### üìù Editing Criteria")
        
        editing_criteria = {}
        section_feedback = {}
        
        # Tabs for different criteria categories
        tabs = st.tabs([
            "Tone & Voice",
            "Content Quality",
            "Structure",
            "SEO Optimization",
            "Legal Compliance",
            "Custom Criteria"
        ])
        
        # Tone & Voice
        with tabs[0]:
            st.markdown("#### Tone and Voice Criteria")
            editing_criteria['tone_and_voice'] = {}
            
            for key, default in EditingCriteria.TONE_AND_VOICE.items():
                value = st.text_area(
                    f"{key.replace('_', ' ').title()}:",
                    value=default,
                    key=f"tone_{key}",
                    help=f"Edit criteria for {key.replace('_', ' ')}"
                )
                editing_criteria['tone_and_voice'][key] = value
        
        # Content Quality
        with tabs[1]:
            st.markdown("#### Content Quality Criteria")
            editing_criteria['content_quality'] = {}
            
            for key, default in EditingCriteria.CONTENT_QUALITY.items():
                value = st.text_area(
                    f"{key.replace('_', ' ').title()}:",
                    value=default,
                    key=f"quality_{key}",
                    help=f"Edit criteria for {key.replace('_', ' ')}"
                )
                editing_criteria['content_quality'][key] = value
        
        # Structure
        with tabs[2]:
            st.markdown("#### Structure Criteria")
            editing_criteria['structure'] = {}
            
            for key, default in EditingCriteria.STRUCTURE.items():
                value = st.text_area(
                    f"{key.replace('_', ' ').title()}:",
                    value=default,
                    key=f"structure_{key}",
                    help=f"Edit criteria for {key.replace('_', ' ')}"
                )
                editing_criteria['structure'][key] = value
        
        # SEO Optimization
        with tabs[3]:
            st.markdown("#### SEO Optimization Criteria")
            editing_criteria['seo_optimization'] = {}
            
            for key, default in EditingCriteria.SEO_OPTIMIZATION.items():
                value = st.text_area(
                    f"{key.replace('_', ' ').title()}:",
                    value=default,
                    key=f"seo_{key}",
                    help=f"Edit criteria for {key.replace('_', ' ')}"
                )
                editing_criteria['seo_optimization'][key] = value
        
        # Legal Compliance
        with tabs[4]:
            st.markdown("#### Legal Compliance Criteria")
            editing_criteria['legal_compliance'] = {}
            
            for key, default in EditingCriteria.LEGAL_COMPLIANCE.items():
                value = st.text_area(
                    f"{key.replace('_', ' ').title()}:",
                    value=default,
                    key=f"legal_{key}",
                    help=f"Edit criteria for {key.replace('_', ' ')}"
                )
                editing_criteria['legal_compliance'][key] = value
        
        # Custom Criteria
        with tabs[5]:
            st.markdown("#### Custom Criteria")
            custom_criteria = st.text_area(
                "Add any additional editing criteria:",
                value="",
                height=200,
                help="Enter any custom editing criteria not covered above"
            )
            if custom_criteria:
                editing_criteria['custom'] = {'additional': custom_criteria}
        
        # Section-specific feedback
        st.write("### üìë Section-Specific Feedback")
        sections = st.session_state['article_draft'].split('\n\n')
        
        for i, section in enumerate(sections):
            with st.expander(f"Section {i+1}", expanded=False):
                st.write(section)
                feedback = st.text_area(
                    "Feedback for this section:",
                    key=f"section_feedback_{i}",
                    help="Enter specific feedback for this section"
                )
                if feedback:
                    section_feedback[i] = feedback
        
        # Generate suggestions
        if st.button("üîç Generate Editing Suggestions", help="Click to generate editing suggestions"):
            with st.spinner("‚úçÔ∏è Generating editing suggestions..."):
                try:
                    result = await generate_editing_suggestions(
                        draft=st.session_state['article_draft'],
                        criteria=editing_criteria,
                        section_feedback=section_feedback,
                        llm_client=llm_client,
                        prompt_handler=prompt_handler,
                        user_email=user_email
                    )
                    
                    if result['success']:
                        # Save editing suggestions
                        content_id = await db_handlers['blog'].save_content(
                            user_email=user_email,
                            content_type='editing_suggestions',
                            content=result['suggestions'],
                            metadata={
                                'draft_id': st.session_state['draft_id'],
                                'criteria': editing_criteria,
                                'section_feedback': section_feedback,
                                'generated_at': datetime.now().isoformat()
                            }
                        )
                        
                        # Update session state
                        st.session_state['editing_suggestions'] = result['suggestions']
                        st.session_state['editing_id'] = content_id
                        
                        # Log activity
                        await db_handlers['analytics'].log_activity(
                            user_email=user_email,
                            activity_type='editing_suggestions',
                            metadata={
                                'content_id': content_id,
                                'draft_id': st.session_state['draft_id']
                            }
                        )
                        
                        # Display suggestions
                        st.success("‚úÖ Editing suggestions generated successfully!")
                        
                        # Suggestions display
                        st.write("### üìã Editing Suggestions")
                        suggestions_sections = result['suggestions'].split('\n\n')
                        
                        for i, suggestion in enumerate(suggestions_sections):
                            with st.expander(f"Suggestion {i+1}", expanded=i==0):
                                st.write(suggestion)
                                
                                # Implementation status
                                status = st.selectbox(
                                    "Implementation Status:",
                                    ["Pending", "In Progress", "Implemented", "Rejected"],
                                    key=f"status_{i}"
                                )
                                if status != "Pending":
                                    st.session_state.setdefault('implementation_status', {})[i] = status
                                
                                # Feedback on suggestion
                                feedback = st.text_area(
                                    "Feedback on this suggestion:",
                                    key=f"suggestion_feedback_{i}"
                                )
                                if feedback:
                                    st.session_state.setdefault('suggestion_feedback', {})[i] = feedback
                        
                        # Export suggestions
                        if st.button("üì§ Export Editing Package"):
                            export_data = {
                                'original_draft': st.session_state['article_draft'],
                                'editing_criteria': editing_criteria,
                                'suggestions': result['suggestions'],
                                'section_feedback': section_feedback,
                                'implementation_status': st.session_state.get('implementation_status', {}),
                                'suggestion_feedback': st.session_state.get('suggestion_feedback', {}),
                                'metadata': {
                                    'generated_at': datetime.now().isoformat(),
                                    'draft_id': st.session_state['draft_id']
                                }
                            }
                            
                            st.download_button(
                                label="üì• Download Editing Package",
                                data=json.dumps(export_data, indent=2),
                                file_name=f"editing_suggestions_{content_id}.json",
                                mime="application/json"
                            )
                        
                    else:
                        st.error(f"‚ùå Failed to generate suggestions: {result.get('error', 'Unknown error')}")
                        
                except Exception as e:
                    st.error(f"‚ùå An error occurred: {str(e)}")
                    logger.error(f"Error in editing suggestions generation: {str(e)}")
        
        # Suggestions history
        with st.expander("üìö Editing History", expanded=False):
            try:
                suggestions_history = await db_handlers['blog'].get_user_content(
                    user_email=user_email,
                    content_type='editing_suggestions',
                    limit=5
                )
                
                if suggestions_history:
                    for entry in suggestions_history:
                        col1, col2, col3 = st.columns([3, 1, 1])
                        
                        with col1:
                            st.write(f"Suggestions from {entry['created_at'].strftime('%Y-%m-%d %H:%M')}")
                            
                        with col2:
                            if st.button("Load", key=f"load_{entry['_id']}"):
                                st.session_state['editing_suggestions'] = entry['content']
                                st.session_state['editing_id'] = str(entry['_id'])
                                st.experimental_rerun()
                                
                        with col3:
                            if st.button("Delete", key=f"delete_{entry['_id']}"):
                                try:
                                    await db_handlers['blog'].delete_content(str(entry['_id']))
                                    st.success("‚úÖ Suggestions deleted successfully!")
                                    st.experimental_rerun()
                                except Exception as e:
                                    st.error(f"‚ùå Error deleting suggestions: {str(e)}")
                        
                        st.markdown("---")
                else:
                    st.info("No previous editing suggestions found.")
                    
            except Exception as e:
                st.error("Failed to load editing history")
                logger.error(f"Error loading editing history: {str(e)}")

        # Help section
        with st.expander("‚ùì Need Help?", expanded=False):
            st.markdown("""
            ### Editing Guidelines
            1. Focus on clarity and consistency
            2. Ensure brand voice alignment
            3. Verify all facts and statistics
            4. Optimize for readability
            5. Maintain professional tone
            
            ### Best Practices
            - Review each section carefully
            - Consider reader perspective
            - Check for logical flow
            - Verify source citations
            - Ensure legal accuracy
            
            ### Support
            Contact: editing@fairnessfactor.com
            """)

    except Exception as e:
        logger.error(f"Error in editing criteria page: {str(e)}")
        st.error("An unexpected error occurred. Please try again.")

if __name__ == "__main__":
    # For testing the page individually
    import os
    from dotenv import load_dotenv
    
    load_dotenv()
    
    async def test_page():
        from utils.mongo_manager import AsyncMongoManager
        from utils.prompt_handler import AsyncPromptHandler
        from llm.llm_client import AsyncLLMClient
        
        mongo_manager = AsyncMongoManager()
        client, db = await mongo_manager.get_connection()
        
        handlers = {
            'blog': None,  # Add your handlers here
            'file': None,
            'analytics': None
        }
        
        await editing_criteria_page(
            handlers,
            AsyncLLMClient(),
            AsyncPromptHandler(db)
        )
    
    asyncio.run(test_page())

================
File: pages/final_article.py
================
# pages/final_article.py
import streamlit as st
import asyncio
from typing import Dict, Any, Optional
from llm.llm_client import AsyncLLMClient
from utils.prompt_handler import AsyncPromptHandler
import logging
import json
import yaml
import re
from datetime import datetime

logger = logging.getLogger(__name__)

def check_page_access(page_name: str) -> bool:
    """Check if user has access to requested page"""
    if not st.session_state.authenticated:
        return False
        
    required_pages = {
        'Topic Research': ['user', 'admin'],
        'Topic Campaign': ['user', 'admin'],
        'Article Draft': ['user', 'admin'],
        'Editing Criteria': ['user', 'admin'],
        'Final Article': ['user', 'admin'],
        'Image Description': ['user', 'admin'],
        'SEO Generation': ['user', 'admin']
    }
    
    user_role = st.session_state.user.get('role', 'user')
    return user_role in required_pages.get(page_name, [])

logger = logging.getLogger(__name__)

class FinalArticleGenerator:
    """Handles final article generation and validation"""
    
    QUALITY_CHECKLIST = {
        "content": [
            "All editing suggestions addressed",
            "Facts and statistics verified",
            "Legal information accurate",
            "Citations properly formatted",
            "Examples relevant and current"
        ],
        "structure": [
            "Logical flow maintained",
            "Transitions smooth",
            "Paragraphs well-organized",
            "Headers properly structured",
            "Sections balanced"
        ],
        "style": [
            "Brand voice consistent",
            "Tone appropriate",
            "Language accessible",
            "Technical terms explained",
            "Writing engaging"
        ],
        "seo": [
            "Keywords naturally incorporated",
            "Meta information optimized",
            "Headers SEO-friendly",
            "Alt text for images",
            "Internal links added"
        ]
    }
    
    @staticmethod
    def validate_article(content: str) -> Dict[str, Any]:
        """Validate final article content"""
        min_length = 1000
        max_length = 5000
        current_length = len(content.split())
        
        return {
            'valid': min_length <= current_length <= max_length,
            'length': current_length,
            'message': f"Article length: {current_length} words (should be between {min_length} and {max_length})"
        }
    
    @staticmethod
    def generate_slug(title: str) -> str:
        """Generate URL-friendly slug from title"""
        # Convert to lowercase and replace spaces with hyphens
        slug = title.lower().strip()
        # Remove special characters
        slug = re.sub(r'[^\w\s-]', '', slug)
        # Replace spaces and repeated hyphens with single hyphen
        slug = re.sub(r'[-\s]+', '-', slug)
        return slug

async def generate_final_article(
    draft: str,
    suggestions: str,
    feedback: Dict[str, Any],
    llm_client: AsyncLLMClient,
    prompt_handler: AsyncPromptHandler,
    user_email: str
) -> Dict[str, Any]:
    """Generate final article incorporating editing suggestions and feedback"""
    try:
        # Check user authentication
        if not user_email:
            raise ValueError("User not authenticated")

        # Format final article prompt
        final_prompt = await prompt_handler.format_prompt(
            'final_article',
            {
                'article_draft': draft,
                'editing_suggestions': suggestions,
                'user_feedback': json.dumps(feedback, indent=2)
            }
        )
        
        if not final_prompt:
            raise ValueError("Failed to format final article prompt")

        # Generate final article
        final_content = await llm_client.generate_response(
            system_prompt=(
                "You are an expert content editor finalizing a Fairness Factor blog article. "
                "Incorporate all editing suggestions while maintaining brand voice and "
                "ensuring the article effectively communicates employee advocacy messages. "
                "Focus on creating engaging, informative content that provides value to readers."
            ),
            user_prompt=final_prompt,
            max_tokens=3000,
            user_email=user_email
        )
        
        # Validate article
        validation = FinalArticleGenerator.validate_article(final_content)
        if not validation['valid']:
            raise ValueError(f"Generated article does not meet requirements: {validation['message']}")
        
        return {
            'success': True,
            'article': final_content,
            'validation': validation
        }
    except Exception as e:
        logger.error(f"Error generating final article: {str(e)}")
        return {
            'success': False,
            'error': str(e)
        }

async def final_article_page(db_handlers, llm_client, prompt_handler):
    """Final Article Page Handler"""
    try:
        # Check authentication and access
        if not st.session_state.authenticated:
            st.warning("Please log in to access this page")
            st.stop()
            return
            
        if not check_page_access('Final Article'):
            st.error("You don't have permission to access this page")
            st.stop()
            return

        user_email = st.session_state.user['email']
        
        # Check prerequisites
        if 'editing_suggestions' not in st.session_state:
            st.warning("‚ö†Ô∏è Please complete the Editing Criteria step first")
            st.stop()
            return

        # Log page access
        await db_handlers['analytics'].log_activity(
            user_email=user_email,
            activity_type='page_access',
            metadata={'page': 'Final Article'}
        )

        # Existing page code continues here...
        
        # Display previous content
        col1, col2 = st.columns(2)
        
        with col1:
            with st.expander("üìÑ Original Draft", expanded=False):
                st.write(st.session_state['article_draft'])
                
        with col2:
            with st.expander("‚úèÔ∏è Editing Suggestions", expanded=False):
                st.write(st.session_state['editing_suggestions'])
        
        # Article metadata
        st.write("### üìã Article Details")
        
        col1, col2 = st.columns(2)
        
        with col1:
            title = st.text_input(
                "Article Title:",
                value=st.session_state.get('selected_topic', ''),
                help="Enter the final article title"
            )
            
            author = st.text_input(
                "Author Name:",
                value=st.session_state.user['name'],
                help="Enter the author's name"
            )
        
        with col2:
            publish_date = st.date_input(
                "Publication Date:",
                value=datetime.now(),
                help="Select planned publication date"
            )
            
            categories = st.multiselect(
                "Categories:",
                ["Employee Rights", "Workplace Safety", "Legal Updates", 
                 "HR Best Practices", "Career Development", "Industry News"],
                help="Select relevant categories"
            )
        
        # Quality checklist
        st.write("### ‚úÖ Quality Checklist")
        
        checklist_status = {}
        for category, items in FinalArticleGenerator.QUALITY_CHECKLIST.items():
            st.write(f"#### {category.title()}")
            for item in items:
                checked = st.checkbox(item, key=f"check_{category}_{item}")
                checklist_status[f"{category}_{item}"] = checked
        
        # Additional feedback
        st.write("### üí≠ Final Revisions")
        
        feedback = {
            "tone_adjustments": st.text_area(
                "Tone Adjustments:",
                help="Any specific adjustments to tone or voice"
            ),
            "content_focus": st.text_area(
                "Content Focus:",
                help="Areas to emphasize or clarify"
            ),
            "additional_notes": st.text_area(
                "Additional Notes:",
                help="Any other feedback for the final version"
            )
        }
        
        # Generate final article
        if st.button("üöÄ Generate Final Article", help="Click to generate the final version"):
            if not title or not author:
                st.error("‚ùå Please fill in all article details.")
                return
                
            with st.spinner("‚úçÔ∏è Generating final article..."):
                try:
                    result = await generate_final_article(
                        draft=st.session_state['article_draft'],
                        suggestions=st.session_state['editing_suggestions'],
                        feedback=feedback,
                        llm_client=llm_client,
                        prompt_handler=prompt_handler,
                        user_email=user_email
                    )
                    
                    if result['success']:
                        # Generate slug
                        slug = FinalArticleGenerator.generate_slug(title)
                        
                        # Prepare metadata
                        metadata = {
                            'title': title,
                            'author': author,
                            'publish_date': publish_date.isoformat(),
                            'categories': categories,
                            'slug': slug,
                            'checklist_status': checklist_status,
                            'feedback': feedback,
                            'word_count': result['validation']['length']
                        }
                        
                        # Save final article
                        content_id = await db_handlers['blog'].save_content(
                            user_email=user_email,
                            content_type='final_article',
                            content=result['article'],
                            metadata={
                                'article_metadata': metadata,
                                'draft_id': st.session_state['draft_id'],
                                'editing_id': st.session_state['editing_id']
                            }
                        )
                        
                        # Update session state
                        st.session_state['final_article'] = result['article']
                        st.session_state['final_id'] = content_id
                        
                        # Log activity
                        await db_handlers['analytics'].log_activity(
                            user_email=user_email,
                            activity_type='final_article',
                            metadata={
                                'content_id': content_id,
                                'title': title
                            }
                        )
                        
                        # Display success and validation
                        st.success("‚úÖ Final article generated successfully!")
                        st.info(result['validation']['message'])
                        
                        # Article preview
                        st.write("### üìñ Final Article Preview")
                        
                        # Article sections
                        sections = result['article'].split('\n\n')
                        for i, section in enumerate(sections):
                            with st.expander(f"Section {i+1}", expanded=i==0):
                                st.write(section)
                        
                        # Export options
                        col1, col2, col3 = st.columns(3)
                        
                        with col1:
                            # Export as Markdown
                            markdown_content = f"""---
title: {title}
author: {author}
date: {publish_date}
categories: {', '.join(categories)}
slug: {slug}
---

{result['article']}
"""
                            st.download_button(
                                label="üì• Export as Markdown",
                                data=markdown_content,
                                file_name=f"article_{slug}.md",
                                mime="text/markdown"
                            )
                        
                        with col2:
                            # Export as JSON
                            export_data = {
                                'metadata': metadata,
                                'content': result['article'],
                                'history': {
                                    'draft_id': st.session_state['draft_id'],
                                    'editing_id': st.session_state['editing_id']
                                }
                            }
                            
                            st.download_button(
                                label="üì§ Export as JSON",
                                data=json.dumps(export_data, indent=2),
                                file_name=f"article_{slug}.json",
                                mime="application/json"
                            )
                        
                        with col3:
                            # Preview formatted
                            if st.button("üëÄ Preview Formatted"):
                                st.markdown(f"# {title}")
                                st.markdown(f"*By {author} | {publish_date}*")
                                st.markdown("---")
                                st.markdown(result['article'])
                        
                    else:
                        st.error(f"‚ùå Failed to generate final article: {result.get('error', 'Unknown error')}")
                        
                except Exception as e:
                    st.error(f"‚ùå An error occurred: {str(e)}")
                    logger.error(f"Error in final article generation: {str(e)}")
        
        # Article history
        with st.expander("üìö Article History", expanded=False):
            try:
                article_history = await db_handlers['blog'].get_user_content(
                    user_email=user_email,
                    content_type='final_article',
                    limit=5
                )
                
                if article_history:
                    for entry in article_history:
                        col1, col2, col3 = st.columns([3, 1, 1])
                        
                        with col1:
                            metadata = entry.get('metadata', {}).get('article_metadata', {})
                            st.write(f"**{metadata.get('title', 'Untitled')}**")
                            st.write(f"Created: {entry['created_at'].strftime('%Y-%m-%d %H:%M')}")
                            
                        with col2:
                            if st.button("Load", key=f"load_{entry['_id']}"):
                                st.session_state['final_article'] = entry['content']
                                st.session_state['final_id'] = str(entry['_id'])
                                st.experimental_rerun()
                                
                        with col3:
                            if st.button("Delete", key=f"delete_{entry['_id']}"):
                                try:
                                    await db_handlers['blog'].delete_content(str(entry['_id']))
                                    st.success("‚úÖ Article deleted successfully!")
                                    st.experimental_rerun()
                                except Exception as e:
                                    st.error(f"‚ùå Error deleting article: {str(e)}")
                        
                        st.markdown("---")
                else:
                    st.info("No previous articles found.")
                    
            except Exception as e:
                st.error("Failed to load article history")
                logger.error(f"Error loading article history: {str(e)}")

        # Help section
        with st.expander("‚ùì Need Help?", expanded=False):
            st.markdown("""
            ### Final Article Guidelines
            1. Ensure all editing suggestions are addressed
            2. Maintain consistent brand voice
            3. Verify all facts and citations
            4. Check for proper formatting
            5. Review SEO optimization
            
            ### Quality Checklist
            - Clear and engaging introduction
            - Logical flow of ideas
            - Strong supporting examples
            - Effective conclusion
            - Call-to-action included
            
            ### Support
            Contact: content@fairnessfactor.com
            """)

    except Exception as e:
        logger.error(f"Error in final article page: {str(e)}")
        st.error("An unexpected error occurred. Please try again.")

if __name__ == "__main__":
    # For testing the page individually
    import os
    from dotenv import load_dotenv
    
    load_dotenv()
    
    async def test_page():
        from utils.mongo_manager import AsyncMongoManager
        from utils.prompt_handler import AsyncPromptHandler
        from llm.llm_client import AsyncLLMClient
        
        mongo_manager = AsyncMongoManager()
        client, db = await mongo_manager.get_connection()
        
        handlers = {
            'blog': None,  # Add your handlers here
            'file': None,
            'analytics': None
        }
        
        await final_article_page(
            handlers,
            AsyncLLMClient(),
            AsyncPromptHandler(db)
        )
    
    asyncio.run(test_page())

================
File: pages/image_description.py
================
# pages/image_description.py
import streamlit as st
import asyncio
from typing import Dict, Any, Optional, List
from llm.llm_client import AsyncLLMClient
from utils.prompt_handler import AsyncPromptHandler
import logging
import json
from PIL import Image
import io
from datetime import datetime

logger = logging.getLogger(__name__)

def check_page_access(page_name: str) -> bool:
    """Check if user has access to requested page"""
    if not st.session_state.authenticated:
        return False
        
    required_pages = {
        'Topic Research': ['user', 'admin'],
        'Topic Campaign': ['user', 'admin'],
        'Article Draft': ['user', 'admin'],
        'Editing Criteria': ['user', 'admin'],
        'Final Article': ['user', 'admin'],
        'Image Description': ['user', 'admin'],
        'SEO Generation': ['user', 'admin']
    }
    
    user_role = st.session_state.user.get('role', 'user')
    return user_role in required_pages.get(page_name, [])

logger = logging.getLogger(__name__)

class ImageDescriptionGenerator:
    """Handles image description generation and validation"""
    
    IMAGE_TYPES = {
        "hero": {
            "name": "Hero Image",
            "description": "Main header image for the article",
            "dimensions": "1200x630px",
            "style": "Professional and impactful"
        },
        "section": {
            "name": "Section Break",
            "description": "Visual break between article sections",
            "dimensions": "800x400px",
            "style": "Subtle and thematic"
        },
        "infographic": {
            "name": "Infographic",
            "description": "Visual representation of data or processes",
            "dimensions": "800x1200px",
            "style": "Clear and informative"
        },
        "testimonial": {
            "name": "Testimonial",
            "description": "Supporting image for quotes or case studies",
            "dimensions": "400x400px",
            "style": "Personal and authentic"
        },
        "icon": {
            "name": "Icon",
            "description": "Small symbolic representation",
            "dimensions": "100x100px",
            "style": "Simple and recognizable"
        }
    }
    
    STYLE_GUIDELINES = {
        "professional": "Corporate and professional style",
        "modern": "Modern and dynamic approach",
        "inclusive": "Diverse and inclusive representation",
        "empowering": "Empowering and positive imagery",
        "authentic": "Genuine and relatable visuals"
    }
    
    COLOR_SCHEMES = {
        "brand": {
            "primary": "#0077BD",
            "secondary": "#003A6E",
            "accent": "#FC510B",
            "neutral": "#F5F5F5"
        },
        "complementary": {
            "warm": ["#FF7500", "#FFB800", "#FFE5B4"],
            "cool": ["#0075E0", "#00A3E0", "#CEF3FF"]
        }
    }
    
    @staticmethod
    def validate_description(description: str) -> Dict[str, Any]:
        """Validate image description"""
        min_length = 100
        max_length = 500
        current_length = len(description)
        
        return {
            'valid': min_length <= current_length <= max_length,
            'length': current_length,
            'message': f"Description length: {current_length} characters (should be between {min_length} and {max_length})"
        }

async def generate_image_description(
    article: str,
    image_type: str,
    style: str,
    color_scheme: List[str],
    additional_notes: str,
    llm_client: AsyncLLMClient,
    prompt_handler: AsyncPromptHandler,
    user_email: str
) -> Dict[str, Any]:
    """Generate image description based on article content and preferences"""
    try:
        # Check user authentication
        if not user_email:
            raise ValueError("User not authenticated")

        # Format image prompt
        image_prompt = await prompt_handler.format_prompt(
            'image_description',
            {
                'article_content': article,
                'image_type': ImageDescriptionGenerator.IMAGE_TYPES[image_type]['description'],
                'style_preference': ImageDescriptionGenerator.STYLE_GUIDELINES[style],
                'color_scheme': ', '.join(color_scheme),
                'additional_notes': additional_notes
            }
        )
        
        if not image_prompt:
            raise ValueError("Failed to format image description prompt")

        # Generate description
        description = await llm_client.generate_response(
            system_prompt=(
                "You are an expert visual designer creating image descriptions for "
                "Fairness Factor blog articles. Focus on professional, inclusive, "
                "and empowering imagery that reinforces the message of employee advocacy. "
                f"Create a detailed description for a {ImageDescriptionGenerator.IMAGE_TYPES[image_type]['name']}."
            ),
            user_prompt=image_prompt,
            max_tokens=1000,
            user_email=user_email
        )
        
        # Validate description
        validation = ImageDescriptionGenerator.validate_description(description)
        if not validation['valid']:
            raise ValueError(f"Generated description does not meet requirements: {validation['message']}")
        
        return {
            'success': True,
            'description': description,
            'validation': validation
        }
    except Exception as e:
        logger.error(f"Error generating image description: {str(e)}")
        return {
            'success': False,
            'error': str(e)
        }

async def image_description_page(db_handlers, llm_client, prompt_handler):
    """Image Description Page Handler"""
    try:
        # Check authentication and access
        if not st.session_state.authenticated:
            st.warning("Please log in to access this page")
            st.stop()
            return
            
        if not check_page_access('Image Description'):
            st.error("You don't have permission to access this page")
            st.stop()
            return

        user_email = st.session_state.user['email']
        
        # Check prerequisites
        if 'final_article' not in st.session_state:
            st.warning("‚ö†Ô∏è Please complete the Final Article step first")
            st.stop()
            return

        # Log page access
        await db_handlers['analytics'].log_activity(
            user_email=user_email,
            activity_type='page_access',
            metadata={'page': 'Image Description'}
        )

        # Existing page code continues here...
        
        # Display article
        with st.expander("üìÑ Final Article", expanded=False):
            st.write(st.session_state['final_article'])
        
        # Image description settings
        st.write("### üé® Image Settings")
        
        col1, col2 = st.columns(2)
        
        with col1:
            image_type = st.selectbox(
                "Image Type:",
                list(ImageDescriptionGenerator.IMAGE_TYPES.keys()),
                format_func=lambda x: ImageDescriptionGenerator.IMAGE_TYPES[x]['name'],
                help="Select the type of image needed"
            )
            
            # Display selected image type details
            st.info(
                f"**Dimensions:** {ImageDescriptionGenerator.IMAGE_TYPES[image_type]['dimensions']}\n\n"
                f"**Style:** {ImageDescriptionGenerator.IMAGE_TYPES[image_type]['style']}"
            )
            
            style_preference = st.selectbox(
                "Style Preference:",
                list(ImageDescriptionGenerator.STYLE_GUIDELINES.keys()),
                format_func=lambda x: ImageDescriptionGenerator.STYLE_GUIDELINES[x],
                help="Select the preferred style"
            )
        
        with col2:
            # Color scheme selection
            st.write("#### Color Scheme")
            
            use_brand_colors = st.checkbox(
                "Use Brand Colors",
                value=True,
                help="Include Fairness Factor brand colors"
            )
            
            if use_brand_colors:
                selected_colors = list(ImageDescriptionGenerator.COLOR_SCHEMES['brand'].keys())
            else:
                selected_colors = st.multiselect(
                    "Select Colors:",
                    list(ImageDescriptionGenerator.COLOR_SCHEMES['complementary'].keys()),
                    default=["warm"],
                    help="Select color preferences"
                )
            
            # Display color preview
            st.write("Selected Colors:")
            colors_html = ""
            if use_brand_colors:
                for color_name, color_code in ImageDescriptionGenerator.COLOR_SCHEMES['brand'].items():
                    colors_html += f'<div style="background-color: {color_code}; width: 50px; height: 20px; display: inline-block; margin-right: 5px;"></div>'
            else:
                for scheme in selected_colors:
                    for color in ImageDescriptionGenerator.COLOR_SCHEMES['complementary'][scheme]:
                        colors_html += f'<div style="background-color: {color}; width: 50px; height: 20px; display: inline-block; margin-right: 5px;"></div>'
            
            st.markdown(colors_html, unsafe_allow_html=True)
        
        # Image composition
        st.write("### üìê Image Composition")
        
        composition_options = {
            "layout": st.selectbox(
                "Layout:",
                ["Centered", "Rule of Thirds", "Golden Ratio", "Symmetrical"],
                help="Select image composition layout"
            ),
            "focus": st.selectbox(
                "Focus Point:",
                ["Center", "Left Third", "Right Third", "Golden Point"],
                help="Select main focus point"
            ),
            "depth": st.selectbox(
                "Depth:",
                ["Flat", "Shallow", "Medium", "Deep"],
                help="Select depth of field"
            )
        }
        
        # Additional notes
        additional_notes = st.text_area(
            "Additional Notes:",
            help="Any specific requirements or preferences for the image"
        )
        
        # Generate description
        if st.button("üé® Generate Image Description", help="Click to generate image description"):
            with st.spinner("‚úçÔ∏è Generating image description..."):
                try:
                    result = await generate_image_description(
                        article=st.session_state['final_article'],
                        image_type=image_type,
                        style=style_preference,
                        color_scheme=selected_colors,
                        additional_notes=additional_notes,
                        llm_client=llm_client,
                        prompt_handler=prompt_handler,
                        user_email=user_email
                    )
                    
                    if result['success']:
                        # Save image description
                        content_id = await db_handlers['blog'].save_content(
                            user_email=user_email,
                            content_type='image_description',
                            content=result['description'],
                            metadata={
                                'final_id': st.session_state['final_id'],
                                'image_type': image_type,
                                'style': style_preference,
                                'color_scheme': selected_colors,
                                'composition': composition_options,
                                'additional_notes': additional_notes
                            }
                        )
                        
                        # Update session state
                        st.session_state['image_description'] = result['description']
                        st.session_state['image_id'] = content_id
                        
                        # Log activity
                        await db_handlers['analytics'].log_activity(
                            user_email=user_email,
                            activity_type='image_description',
                            metadata={
                                'content_id': content_id,
                                'image_type': image_type
                            }
                        )
                        
                        # Display success and validation
                        st.success("‚úÖ Image description generated successfully!")
                        st.info(result['validation']['message'])
                        
                        # Description display
                        st.write("### üìù Generated Description")
                        
                        # Display description with editing option
                        edited_description = st.text_area(
                            "Edit Description:",
                            value=result['description'],
                            height=300,
                            key="edit_description"
                        )
                        
                        if edited_description != result['description']:
                            if st.button("üíæ Save Edited Description"):
                                validation = ImageDescriptionGenerator.validate_description(edited_description)
                                if validation['valid']:
                                    await db_handlers['blog'].update_content(
                                        content_id,
                                        {'content': edited_description}
                                    )
                                    st.session_state['image_description'] = edited_description
                                    st.success("‚úÖ Description updated successfully!")
                                else:
                                    st.error(validation['message'])
                        
                        # Technical specifications
                        st.write("### üìã Technical Specifications")
                        
                        specs = {
                            "Type": ImageDescriptionGenerator.IMAGE_TYPES[image_type]['name'],
                            "Dimensions": ImageDescriptionGenerator.IMAGE_TYPES[image_type]['dimensions'],
                            "Style": ImageDescriptionGenerator.STYLE_GUIDELINES[style_preference],
                            "Color Scheme": ", ".join(selected_colors),
                            "Layout": composition_options['layout'],
                            "Focus Point": composition_options['focus'],
                            "Depth": composition_options['depth']
                        }
                        
                        for key, value in specs.items():
                            st.write(f"**{key}:** {value}")
                        
                        # Export options
                        if st.button("üì§ Export Image Package"):
                            export_data = {
                                'description': edited_description or result['description'],
                                'specifications': specs,
                                'metadata': {
                                    'generated_at': datetime.now().isoformat(),
                                    'article_id': st.session_state['final_id'],
                                    'composition': composition_options,
                                    'additional_notes': additional_notes
                                }
                            }
                            
                            st.download_button(
                                label="üì• Download Image Package",
                                data=json.dumps(export_data, indent=2),
                                file_name=f"image_specs_{content_id}.json",
                                mime="application/json"
                            )
                        
                    else:
                        st.error(f"‚ùå Failed to generate description: {result.get('error', 'Unknown error')}")
                        
                except Exception as e:
                    st.error(f"‚ùå An error occurred: {str(e)}")
                    logger.error(f"Error in image description generation: {str(e)}")
        
        # Description history
        with st.expander("üìö Description History", expanded=False):
            try:
                description_history = await db_handlers['blog'].get_user_content(
                    user_email=user_email,
                    content_type='image_description',
                    limit=5
                )
                
                if description_history:
                    for entry in description_history:
                        col1, col2, col3 = st.columns([3, 1, 1])
                        
                        with col1:
                            st.write(f"Description from {entry['created_at'].strftime('%Y-%m-%d %H:%M')}")
                            st.write(f"Type: {entry['metadata'].get('image_type', 'Unknown')}")
                            
                        with col2:
                            if st.button("Load", key=f"load_{entry['_id']}"):
                                st.session_state['image_description'] = entry['content']
                                st.session_state['image_id'] = str(entry['_id'])
                                st.experimental_rerun()
                                
                        with col3:
                            if st.button("Delete", key=f"delete_{entry['_id']}"):
                                try:
                                    await db_handlers['blog'].delete_content(str(entry['_id']))
                                    st.success("‚úÖ Description deleted successfully!")
                                    st.experimental_rerun()
                                except Exception as e:
                                    st.error(f"‚ùå Error deleting description: {str(e)}")
                        
                        st.markdown("---")
                else:
                    st.info("No previous descriptions found.")
                    
            except Exception as e:
                st.error("Failed to load description history")
                logger.error(f"Error loading description history: {str(e)}")

        # Help section
        with st.expander("‚ùì Need Help?", expanded=False):
            st.markdown("""
            ### Image Guidelines
            1. Focus on professional quality
            2. Maintain brand consistency
            3. Ensure inclusive representation
            4. Consider image context
            5. Follow technical specifications
            
            ### Best Practices
            - Use high-quality images
            - Consider composition rules
            - Match article tone
            - Include diverse representation
            - Follow brand guidelines
            
            ### Support
            Contact: design@fairnessfactor.com
            """)

    except Exception as e:
        logger.error(f"Error in image description page: {str(e)}")
        st.error("An unexpected error occurred. Please try again.")

if __name__ == "__main__":
    # For testing the page individually
    import os
    from dotenv import load_dotenv
    
    load_dotenv()
    
    async def test_page():
        from utils.mongo_manager import AsyncMongoManager
        from utils.prompt_handler import AsyncPromptHandler
        from llm.llm_client import AsyncLLMClient
        
        mongo_manager = AsyncMongoManager()
        client, db = await mongo_manager.get_connection()
        
        handlers = {
            'blog': None,  # Add your handlers here
            'file': None,
            'analytics': None
        }
        
        await image_description_page(
            handlers,
            AsyncLLMClient(),
            AsyncPromptHandler(db)
        )
    
    asyncio.run(test_page())

================
File: pages/seo_generation.py
================
# pages/seo_generation.py
import streamlit as st
import asyncio
from typing import Dict, Any, Optional, List
from llm.llm_client import AsyncLLMClient
from utils.prompt_handler import AsyncPromptHandler
import logging
import json
import re
from datetime import datetime

logger = logging.getLogger(__name__)

def check_page_access(page_name: str) -> bool:
    """Check if user has access to requested page"""
    if not st.session_state.authenticated:
        return False
        
    required_pages = {
        'Topic Research': ['user', 'admin'],
        'Topic Campaign': ['user', 'admin'],
        'Article Draft': ['user', 'admin'],
        'Editing Criteria': ['user', 'admin'],
        'Final Article': ['user', 'admin'],
        'Image Description': ['user', 'admin'],
        'SEO Generation': ['user', 'admin']
    }
    
    user_role = st.session_state.user.get('role', 'user')
    return user_role in required_pages.get(page_name, [])

logger = logging.getLogger(__name__)

class SEOGenerator:
    """Handles SEO content generation and validation"""
    
    META_REQUIREMENTS = {
        "title": {
            "min_length": 30,
            "max_length": 60,
            "required_elements": ["brand", "keyword"]
        },
        "description": {
            "min_length": 120,
            "max_length": 160,
            "required_elements": ["value proposition", "call to action"]
        }
    }
    
    SCHEMA_TYPES = {
        "article": {
            "name": "Article Schema",
            "required_fields": ["headline", "author", "datePublished", "publisher"]
        },
        "organization": {
            "name": "Organization Schema",
            "required_fields": ["name", "url", "logo", "contactPoint"]
        },
        "faq": {
            "name": "FAQ Schema",
            "required_fields": ["questions", "answers"]
        }
    }
    
    KEYWORD_TYPES = {
        "primary": "Main focus keyword",
        "secondary": "Supporting keywords",
        "long_tail": "Long-tail variations",
        "related": "Related terms",
        "lsi": "Latent Semantic Indexing keywords"
    }
    
    @staticmethod
    def validate_meta_title(title: str) -> Dict[str, Any]:
        """Validate meta title"""
        length = len(title)
        return {
            'valid': 30 <= length <= 60,
            'length': length,
            'message': f"Title length: {length}/60 characters"
        }
    
    @staticmethod
    def validate_meta_description(description: str) -> Dict[str, Any]:
        """Validate meta description"""
        length = len(description)
        return {
            'valid': 120 <= length <= 160,
            'length': length,
            'message': f"Description length: {length}/160 characters"
        }
    
    @staticmethod
    def generate_slug(title: str) -> str:
        """Generate URL slug from title"""
        slug = title.lower().strip()
        slug = re.sub(r'[^\w\s-]', '', slug)
        slug = re.sub(r'[-\s]+', '-', slug)
        return slug

async def generate_seo_content(
    article: str,
    image_description: str,
    target_keywords: List[str],
    schema_types: List[str],
    llm_client: AsyncLLMClient,
    prompt_handler: AsyncPromptHandler,
    user_email: str
) -> Dict[str, Any]:
    """Generate SEO content based on article and keywords"""
    try:
        # Check user authentication
        if not user_email:
            raise ValueError("User not authenticated")

        # Format SEO prompt
        seo_prompt = await prompt_handler.format_prompt(
            'seo_generation',
            {
                'article_content': article,
                'image_description': image_description,
                'target_keywords': ', '.join(target_keywords),
                'schema_types': ', '.join(schema_types)
            }
        )
        
        if not seo_prompt:
            raise ValueError("Failed to format SEO prompt")

        # Generate SEO content
        seo_content = await llm_client.generate_response(
            system_prompt=(
                "You are an SEO expert optimizing content for Fairness Factor's blog. "
                "Focus on employee advocacy keywords while maintaining natural language "
                "and providing comprehensive meta information for optimal search visibility. "
                "Generate schema markup for specified types and ensure all meta elements "
                "follow best practices."
            ),
            user_prompt=seo_prompt,
            max_tokens=2000,
            user_email=user_email
        )
        
        # Parse SEO content into structured format
        try:
            seo_data = json.loads(seo_content)
        except json.JSONDecodeError:
            raise ValueError("Generated SEO content is not in valid JSON format")
        
        # Validate meta elements
        title_validation = SEOGenerator.validate_meta_title(seo_data.get('meta_title', ''))
        desc_validation = SEOGenerator.validate_meta_description(seo_data.get('meta_description', ''))
        
        if not title_validation['valid'] or not desc_validation['valid']:
            raise ValueError("Generated meta elements do not meet requirements")
        
        return {
            'success': True,
            'seo_data': seo_data,
            'validations': {
                'title': title_validation,
                'description': desc_validation
            }
        }
    except Exception as e:
        logger.error(f"Error generating SEO content: {str(e)}")
        return {
            'success': False,
            'error': str(e)
        }

async def seo_generation_page(db_handlers, llm_client, prompt_handler):
    """SEO Generation Page Handler"""
    try:
        # Check authentication and access
        if not st.session_state.authenticated:
            st.warning("Please log in to access this page")
            st.stop()
            return
            
        if not check_page_access('SEO Generation'):
            st.error("You don't have permission to access this page")
            st.stop()
            return

        user_email = st.session_state.user['email']
        
        # Check prerequisites
        if 'final_article' not in st.session_state or 'image_description' not in st.session_state:
            st.warning("‚ö†Ô∏è Please complete the Final Article and Image Description steps first")
            st.stop()
            return

        # Log page access
        await db_handlers['analytics'].log_activity(
            user_email=user_email,
            activity_type='page_access',
            metadata={'page': 'SEO Generation'}
        )

        # Existing page code continues here...
        
        # Display previous content
        with st.expander("üìÑ Article Content", expanded=False):
            st.write(st.session_state['final_article'])
            st.write("### Image Description")
            st.write(st.session_state['image_description'])
        
        # SEO Settings
        st.write("### üéØ SEO Target Settings")
        
        col1, col2 = st.columns(2)
        
        with col1:
            # Keyword settings
            st.write("#### Keyword Strategy")
            
            primary_keyword = st.text_input(
                "Primary Keyword:",
                help="Enter the main keyword to target"
            )
            
            secondary_keywords = st.text_area(
                "Secondary Keywords (one per line):",
                help="Enter supporting keywords"
            ).split('\n')
            
            long_tail_keywords = st.text_area(
                "Long-tail Keywords (one per line):",
                help="Enter long-tail keyword variations"
            ).split('\n')
        
        with col2:
            # Target settings
            st.write("#### Target Settings")
            
            target_location = st.selectbox(
                "Target Location:",
                ["Global", "United States", "Europe", "Asia"],
                help="Select primary geographic target"
            )
            
            target_devices = st.multiselect(
                "Target Devices:",
                ["Desktop", "Mobile", "Tablet"],
                default=["Desktop", "Mobile"],
                help="Select target devices"
            )
            
            target_audience = st.multiselect(
                "Target Audience:",
                ["Employees", "HR Professionals", "Business Leaders", "Legal Professionals"],
                default=["Employees"],
                help="Select target audience segments"
            )
        
        # Schema Markup Settings
        st.write("### üìù Schema Markup")
        
        selected_schemas = st.multiselect(
            "Select Schema Types:",
            list(SEOGenerator.SCHEMA_TYPES.keys()),
            default=["article"],
            format_func=lambda x: SEOGenerator.SCHEMA_TYPES[x]['name'],
            help="Select schema markup types to generate"
        )
        
        # Advanced SEO Settings
        with st.expander("‚öôÔ∏è Advanced SEO Settings", expanded=False):
            col1, col2 = st.columns(2)
            
            with col1:
                search_intent = st.selectbox(
                    "Search Intent:",
                    ["Informational", "Navigational", "Commercial", "Transactional"],
                    help="Select primary search intent"
                )
                
                content_type = st.selectbox(
                    "Content Type:",
                    ["Blog Post", "Article", "Guide", "Case Study"],
                    help="Select content type for schema markup"
                )
            
            with col2:
                competition_level = st.slider(
                    "Competition Level:",
                    min_value=1,
                    max_value=10,
                    value=5,
                    help="Estimate keyword competition level"
                )
                
                readability_target = st.select_slider(
                    "Readability Target:",
                    options=["Basic", "Intermediate", "Advanced", "Expert"],
                    value="Intermediate",
                    help="Select target readability level"
                )
        
        # Generate SEO content
        if st.button("üöÄ Generate SEO Content", help="Click to generate SEO optimization content"):
            if not primary_keyword:
                st.error("‚ùå Please enter a primary keyword.")
                return
                
            with st.spinner("‚úçÔ∏è Generating SEO content..."):
                try:
                    result = await generate_seo_content(
                        article=st.session_state['final_article'],
                        image_description=st.session_state['image_description'],
                        target_keywords=[primary_keyword] + secondary_keywords + long_tail_keywords,
                        schema_types=selected_schemas,
                        llm_client=llm_client,
                        prompt_handler=prompt_handler,
                        user_email=user_email
                    )
                    
                    if result['success']:
                        seo_data = result['seo_data']
                        
                        # Save SEO content
                        content_id = await db_handlers['blog'].save_content(
                            user_email=user_email,
                            content_type='seo_content',
                            content=json.dumps(seo_data),
                            metadata={
                                'final_id': st.session_state['final_id'],
                                'primary_keyword': primary_keyword,
                                'secondary_keywords': secondary_keywords,
                                'long_tail_keywords': long_tail_keywords,
                                'target_location': target_location,
                                'target_devices': target_devices,
                                'target_audience': target_audience,
                                'search_intent': search_intent,
                                'content_type': content_type,
                                'competition_level': competition_level,
                                'readability_target': readability_target
                            }
                        )
                        
                        # Update session state
                        st.session_state['seo_content'] = seo_data
                        st.session_state['seo_id'] = content_id
                        
                        # Log activity
                        await db_handlers['analytics'].log_activity(
                            user_email=user_email,
                            activity_type='seo_generation',
                            metadata={
                                'content_id': content_id,
                                'primary_keyword': primary_keyword
                            }
                        )
                        
                        # Display SEO content
                        st.success("‚úÖ SEO content generated successfully!")
                        
                        # Meta Information
                        st.write("### üìä Meta Information")
                        
                        col1, col2 = st.columns(2)
                        
                        with col1:
                            meta_title = st.text_input(
                                "Meta Title:",
                                value=seo_data.get('meta_title', ''),
                                help="Edit meta title"
                            )
                            
                            title_validation = SEOGenerator.validate_meta_title(meta_title)
                            st.write(title_validation['message'])
                            if not title_validation['valid']:
                                st.warning("‚ö†Ô∏è Title length should be between 30-60 characters")
                        
                        with col2:
                            meta_description = st.text_area(
                                "Meta Description:",
                                value=seo_data.get('meta_description', ''),
                                help="Edit meta description"
                            )
                            
                            desc_validation = SEOGenerator.validate_meta_description(meta_description)
                            st.write(desc_validation['message'])
                            if not desc_validation['valid']:
                                st.warning("‚ö†Ô∏è Description length should be between 120-160 characters")
                        
                        # URL Slug
                        suggested_slug = SEOGenerator.generate_slug(meta_title)
                        url_slug = st.text_input(
                            "URL Slug:",
                            value=suggested_slug,
                            help="Edit URL slug"
                        )
                        
                        # Keyword Analysis
                        st.write("### üîç Keyword Analysis")
                        
                        keyword_data = seo_data.get('keyword_analysis', {})
                        for keyword_type, keywords in keyword_data.items():
                            with st.expander(f"{keyword_type.title()} Keywords"):
                                edited_keywords = st.text_area(
                                    f"Edit {keyword_type} keywords:",
                                    value='\n'.join(keywords),
                                    key=f"edit_{keyword_type}"
                                ).split('\n')
                                keyword_data[keyword_type] = edited_keywords
                        
                        # Schema Markup
                        st.write("### üìù Schema Markup")
                        schema_markup = seo_data.get('schema_markup', {})
                        for schema_type in selected_schemas:
                            with st.expander(f"{SEOGenerator.SCHEMA_TYPES[schema_type]['name']}"):
                                schema_json = st.text_area(
                                    f"Edit {schema_type} schema:",
                                    value=json.dumps(schema_markup.get(schema_type, {}), indent=2),
                                    height=200,
                                    key=f"schema_{schema_type}"
                                )
                                try:
                                    schema_markup[schema_type] = json.loads(schema_json)
                                except json.JSONDecodeError:
                                    st.error("‚ùå Invalid JSON format")
                        
                        # Save changes
                        if st.button("üíæ Save SEO Changes"):
                            try:
                                updated_seo_data = {
                                    'meta_title': meta_title,
                                    'meta_description': meta_description,
                                    'url_slug': url_slug,
                                    'keyword_analysis': keyword_data,
                                    'schema_markup': schema_markup
                                }
                                
                                await db_handlers['blog'].update_content(
                                    content_id,
                                    {'content': json.dumps(updated_seo_data)}
                                )
                                
                                st.session_state['seo_content'] = updated_seo_data
                                st.success("‚úÖ SEO content updated successfully!")
                                
                            except Exception as e:
                                st.error(f"‚ùå Error saving SEO content: {str(e)}")
                        
                        # Export options
                        if st.button("üì§ Export SEO Package"):
                            export_data = {
                                'meta_information': {
                                    'title': meta_title,
                                    'description': meta_description,
                                    'url_slug': url_slug
                                },
                                'keyword_analysis': keyword_data,
                                'schema_markup': schema_markup,
                                'settings': {
                                    'target_location': target_location,
                                    'target_devices': target_devices,
                                    'target_audience': target_audience,
                                    'search_intent': search_intent,
                                    'content_type': content_type,
                                    'competition_level': competition_level,
                                    'readability_target': readability_target
                                }
                            }
                            
                            st.download_button(
                                label="üì• Download SEO Package",
                                data=json.dumps(export_data, indent=2),
                                file_name=f"seo_package_{content_id}.json",
                                mime="application/json"
                            )
                        
                    else:
                        st.error(f"‚ùå Failed to generate SEO content: {result.get('error', 'Unknown error')}")
                        
                except Exception as e:
                    st.error(f"‚ùå An error occurred: {str(e)}")
                    logger.error(f"Error in SEO content generation: {str(e)}")
        
        # SEO History
        with st.expander("üìö SEO History", expanded=False):
            try:
                seo_history = await db_handlers['blog'].get_user_content(
                    user_email=user_email,
                    content_type='seo_content',
                    limit=5
                )
                
                if seo_history:
                    for entry in seo_history:
                        col1, col2, col3 = st.columns([3, 1, 1])
                        
                        with col1:
                            metadata = entry.get('metadata', {})
                            st.write(f"**Primary Keyword:** {metadata.get('primary_keyword', 'Unknown')}")
                            st.write(f"Generated: {entry['created_at'].strftime('%Y-%m-%d %H:%M')}")
                            
                        with col2:
                            if st.button("Load", key=f"load_{entry['_id']}"):
                                st.session_state['seo_content'] = json.loads(entry['content'])
                                st.session_state['seo_id'] = str(entry['_id'])
                                st.experimental_rerun()
                                
                        with col3:
                            if st.button("Delete", key=f"delete_{entry['_id']}"):
                                try:
                                    await db_handlers['blog'].delete_content(str(entry['_id']))
                                    st.success("‚úÖ SEO content deleted successfully!")
                                    st.experimental_rerun()
                                except Exception as e:
                                    st.error(f"‚ùå Error deleting SEO content: {str(e)}")
                        
                        st.markdown("---")
                else:
                    st.info("No previous SEO content found.")
                    
            except Exception as e:
                st.error("Failed to load SEO history")
                logger.error(f"Error loading SEO history: {str(e)}")

        # Help section
        with st.expander("‚ùì Need Help?", expanded=False):
            st.markdown("""
            ### SEO Guidelines
            1. Use target keywords naturally
            2. Optimize meta information
            3. Create descriptive URLs
            4. Implement proper schema markup
            5. Consider search intent
            
            ### Best Practices
            - Keep titles under 60 characters
            - Meta descriptions between 120-160 characters
            - Use relevant keywords
            - Include call-to-action
            - Optimize for mobile
            
            ### Support
            Contact: seo@fairnessfactor.com
            """)

    except Exception as e:
        logger.error(f"Error in SEO generation page: {str(e)}")
        st.error("An unexpected error occurred. Please try again.")

if __name__ == "__main__":
    # For testing the page individually
    import os
    from dotenv import load_dotenv
    
    load_dotenv()
    
    async def test_page():
        from utils.mongo_manager import AsyncMongoManager
        from utils.prompt_handler import AsyncPromptHandler
        from llm.llm_client import AsyncLLMClient
        
        mongo_manager = AsyncMongoManager()
        client, db = await mongo_manager.get_connection()
        
        handlers = {
            'blog': None,  # Add your handlers here
            'file': None,
            'analytics': None
        }
        
        await seo_generation_page(
            handlers,
            AsyncLLMClient(),
            AsyncPromptHandler(db)
        )
    
    asyncio.run(test_page())

================
File: pages/topic_campaign.py
================
# pages/topic_campaign.py
import streamlit as st
import asyncio
import json
from typing import Dict, Any, Optional
from llm.llm_client import AsyncLLMClient
from utils.prompt_handler import AsyncPromptHandler
import logging
from datetime import datetime

logger = logging.getLogger(__name__)

def check_page_access(page_name: str) -> bool:
    """Check if user has access to requested page"""
    if not st.session_state.authenticated:
        return False
        
    required_pages = {
        'Topic Research': ['user', 'admin'],
        'Topic Campaign': ['user', 'admin'],
        'Article Draft': ['user', 'admin'],
        'Editing Criteria': ['user', 'admin'],
        'Final Article': ['user', 'admin'],
        'Image Description': ['user', 'admin'],
        'SEO Generation': ['user', 'admin']
    }
    
    user_role = st.session_state.user.get('role', 'user')
    return user_role in required_pages.get(page_name, [])

logger = logging.getLogger(__name__)

class CampaignGenerator:
    """Handles campaign generation and validation"""
    
    CAMPAIGN_TYPES = {
        "standard": "Regular blog content campaign",
        "series": "Multi-part article series",
        "themed": "Theme-based content campaign",
        "seasonal": "Seasonal or timely campaign"
    }
    
    @staticmethod
    def validate_campaign(campaign: str) -> bool:
        """Validate campaign content"""
        if not campaign or len(campaign.strip()) < 100:
            return False
        return True

async def generate_campaign(
    research_analysis: str,
    campaign_type: str,
    additional_notes: str,
    llm_client: AsyncLLMClient,
    prompt_handler: AsyncPromptHandler,
    user_email: str
) -> Dict[str, Any]:
    """Generate topic campaign asynchronously"""
    try:
        # Check user authentication
        if not user_email:
            raise ValueError("User not authenticated")

        # Format campaign prompt
        campaign_prompt = await prompt_handler.format_prompt(
            'topic_campaign',
            {
                'research_analysis': research_analysis,
                'campaign_type': campaign_type,
                'additional_notes': additional_notes
            }
        )
        
        if not campaign_prompt:
            raise ValueError("Failed to format campaign prompt")

        # Generate campaign
        campaign = await llm_client.generate_response(
            system_prompt=(
                "You are an AI strategist creating content campaigns for Fairness Factor. "
                "Focus on employee advocacy topics that align with the company's mission. "
                f"Generate a {campaign_type} campaign that addresses key workplace issues."
            ),
            user_prompt=campaign_prompt,
            max_tokens=1500,
            user_email=user_email
        )
        
        if not CampaignGenerator.validate_campaign(campaign):
            raise ValueError("Generated campaign does not meet minimum requirements")
        
        return {
            'success': True,
            'campaign': campaign
        }
    except Exception as e:
        logger.error(f"Error generating campaign: {str(e)}")
        return {
            'success': False,
            'error': str(e)
        }

async def topic_campaign_page(db_handlers, llm_client, prompt_handler):
    """Topic Campaign Page Handler"""
    try:
        # Check authentication and access
        if not st.session_state.authenticated:
            st.warning("Please log in to access this page")
            st.stop()
            return
            
        if not check_page_access('Topic Campaign'):
            st.error("You don't have permission to access this page")
            st.stop()
            return

        user_email = st.session_state.user['email']
        
        # Check prerequisites
        if 'research_analysis' not in st.session_state:
            st.warning("‚ö†Ô∏è Please complete the Topic Research step first")
            st.stop()
            return

        # Log page access
        await db_handlers['analytics'].log_activity(
            user_email=user_email,
            activity_type='page_access',
            metadata={'page': 'Topic Campaign'}
        )

        # Existing page code continues here...
        
        # Display research analysis
        with st.expander("üìä Research Analysis", expanded=False):
            st.write(st.session_state['research_analysis'])
        
        # Campaign settings
        st.write("### üìã Campaign Settings")
        
        col1, col2 = st.columns(2)
        
        with col1:
            campaign_type = st.selectbox(
                "Campaign Type:",
                list(CampaignGenerator.CAMPAIGN_TYPES.keys()),
                format_func=lambda x: CampaignGenerator.CAMPAIGN_TYPES[x],
                help="Select the type of content campaign"
            )
            
            target_audience = st.multiselect(
                "Target Audience:",
                ["Employees", "HR Professionals", "Business Leaders", "Legal Professionals"],
                default=["Employees"],
                help="Select target audience segments"
            )
        
        with col2:
            campaign_duration = st.selectbox(
                "Campaign Duration:",
                ["1 month", "3 months", "6 months", "12 months"],
                help="Select campaign duration"
            )
            
            content_frequency = st.selectbox(
                "Content Frequency:",
                ["Weekly", "Bi-weekly", "Monthly"],
                help="Select content publication frequency"
            )
        
        # Additional notes
        additional_notes = st.text_area(
            "Additional Notes:",
            help="Add any specific requirements or focus areas for the campaign"
        )
        
        # Generate campaign
        if st.button("üöÄ Generate Campaign", help="Click to generate topic campaign"):
            with st.spinner("‚úçÔ∏è Generating campaign..."):
                try:
                    result = await generate_campaign(
                        research_analysis=st.session_state['research_analysis'],
                        campaign_type=campaign_type,
                        additional_notes=additional_notes,
                        llm_client=llm_client,
                        prompt_handler=prompt_handler,
                        user_email=user_email
                    )
                    
                    if result['success']:
                        # Save campaign content
                        content_id = await db_handlers['blog'].save_content(
                            user_email=user_email,
                            content_type='campaign',
                            content=result['campaign'],
                            metadata={
                                'research_id': st.session_state['research_id'],
                                'campaign_type': campaign_type,
                                'target_audience': target_audience,
                                'campaign_duration': campaign_duration,
                                'content_frequency': content_frequency,
                                'additional_notes': additional_notes
                            }
                        )
                        
                        # Update session state
                        st.session_state['topic_campaign'] = result['campaign']
                        st.session_state['campaign_id'] = content_id
                        
                        # Log activity
                        await db_handlers['analytics'].log_activity(
                            user_email=user_email,
                            activity_type='campaign_generation',
                            metadata={
                                'content_id': content_id,
                                'campaign_type': campaign_type
                            }
                        )
                        
                        # Display campaign
                        st.success("‚úÖ Campaign generated successfully!")
                        
                        # Campaign overview
                        st.write("### üìë Campaign Overview")
                        campaign_sections = result['campaign'].split('\n\n')
                        
                        for i, section in enumerate(campaign_sections):
                            with st.expander(f"Section {i+1}", expanded=i==0):
                                st.write(section)
                                
                                # Add implementation status
                                status = st.selectbox(
                                    "Implementation Status:",
                                    ["Planned", "In Progress", "Completed", "On Hold"],
                                    key=f"status_{i}"
                                )
                                if status != "Planned":
                                    st.session_state.setdefault('campaign_status', {})[i] = status
                        
                        # Topic selection
                        st.write("### üéØ Topic Selection")
                        topics = [line.strip() for line in result['campaign'].split('\n') 
                                if line.strip() and not line.startswith('#')]
                        
                        selected_topic = st.selectbox(
                            "Select a topic for your next article:",
                            topics,
                            help="Choose the topic you want to write about"
                        )
                        
                        if selected_topic:
                            st.session_state['selected_topic'] = selected_topic
                            
                            # Save selected topic
                            await db_handlers['blog'].update_content(
                                content_id,
                                {'metadata.selected_topic': selected_topic}
                            )
                        
                        # Export campaign
                        if st.button("üì§ Export Campaign"):
                            export_data = {
                                'campaign': result['campaign'],
                                'metadata': {
                                    'campaign_type': campaign_type,
                                    'target_audience': target_audience,
                                    'campaign_duration': campaign_duration,
                                    'content_frequency': content_frequency,
                                    'selected_topic': selected_topic,
                                    'status': st.session_state.get('campaign_status', {})
                                }
                            }
                            
                            st.download_button(
                                label="üì• Download Campaign",
                                data=json.dumps(export_data, indent=2),
                                file_name=f"campaign_{content_id}.json",
                                mime="application/json"
                            )
                        
                    else:
                        st.error(f"‚ùå Campaign generation failed: {result.get('error', 'Unknown error')}")
                        
                except Exception as e:
                    st.error(f"‚ùå An error occurred: {str(e)}")
                    logger.error(f"Error in campaign generation: {str(e)}")
        
        # Campaign history
        with st.expander("üìö Campaign History", expanded=False):
            try:
                campaign_history = await db_handlers['blog'].get_user_content(
                    user_email=user_email,
                    content_type='campaign',
                    limit=5
                )
                
                if campaign_history:
                    for entry in campaign_history:
                        col1, col2, col3 = st.columns([3, 1, 1])
                        
                        with col1:
                            st.write(f"Campaign from {entry['created_at'].strftime('%Y-%m-%d %H:%M')}")
                            st.write(f"Type: {entry['metadata'].get('campaign_type', 'Unknown')}")
                            
                        with col2:
                            if st.button("Load", key=f"load_{entry['_id']}"):
                                st.session_state['topic_campaign'] = entry['content']
                                st.session_state['campaign_id'] = str(entry['_id'])
                                st.experimental_rerun()
                                
                        with col3:
                            if st.button("Delete", key=f"delete_{entry['_id']}"):
                                try:
                                    await db_handlers['blog'].delete_content(str(entry['_id']))
                                    st.success("‚úÖ Campaign deleted successfully!")
                                    st.experimental_rerun()
                                except Exception as e:
                                    st.error(f"‚ùå Error deleting campaign: {str(e)}")
                        
                        st.markdown("---")
                else:
                    st.info("No previous campaigns found.")
                    
            except Exception as e:
                st.error("Failed to load campaign history")
                logger.error(f"Error loading campaign history: {str(e)}")

        # Help section
        with st.expander("‚ùì Need Help?", expanded=False):
            st.markdown("""
            ### Campaign Guidelines
            1. Focus on employee advocacy themes
            2. Consider current workplace trends
            3. Address common pain points
            4. Include actionable insights
            5. Maintain consistent messaging
            
            ### Best Practices
            - Plan content calendar
            - Define clear objectives
            - Consider audience needs
            - Track engagement metrics
            - Adjust based on feedback
            
            ### Support
            Contact: content@fairnessfactor.com
            """)

    except Exception as e:
        logger.error(f"Error in topic campaign page: {str(e)}")
        st.error("An unexpected error occurred. Please try again.")

if __name__ == "__main__":
    # For testing the page individually
    import os
    from dotenv import load_dotenv
    
    load_dotenv()
    
    async def test_page():
        from utils.mongo_manager import AsyncMongoManager
        from utils.prompt_handler import AsyncPromptHandler
        from llm.llm_client import AsyncLLMClient
        
        mongo_manager = AsyncMongoManager()
        client, db = await mongo_manager.get_connection()
        
        handlers = {
            'blog': None,  # Add your handlers here
            'file': None,
            'analytics': None
        }
        
        await topic_campaign_page(
            handlers,
            AsyncLLMClient(),
            AsyncPromptHandler(db)
        )
    
    asyncio.run(test_page())

================
File: pages/topic_research.py
================
# pages/topic_research.py
import streamlit as st
import asyncio
from typing import List, Dict, Any, Optional
import PyPDF2
import docx2txt
from llm.llm_client import AsyncLLMClient
from utils.prompt_handler import AsyncPromptHandler
import logging
import io
from datetime import datetime

logger = logging.getLogger(__name__)

def check_page_access(page_name: str) -> bool:
    """Check if user has access to requested page"""
    if not st.session_state.authenticated:
        return False
        
    required_pages = {
        'Topic Research': ['user', 'admin'],
        'Topic Campaign': ['user', 'admin'],
        'Article Draft': ['user', 'admin'],
        'Editing Criteria': ['user', 'admin'],
        'Final Article': ['user', 'admin'],
        'Image Description': ['user', 'admin'],
        'SEO Generation': ['user', 'admin']
    }
    
    user_role = st.session_state.user.get('role', 'user')
    return user_role in required_pages.get(page_name, [])

logger = logging.getLogger(__name__)

async def process_pdf(file_data: bytes) -> Optional[str]:
    """Process PDF file and extract text content"""
    try:
        pdf_file = io.BytesIO(file_data)
        pdf_reader = PyPDF2.PdfReader(pdf_file)
        content = []
        
        for page in pdf_reader.pages:
            content.append(page.extract_text())
            
        return "\n".join(content)
    except Exception as e:
        logger.error(f"Error processing PDF: {str(e)}")
        return None

async def process_docx(file_data: bytes) -> Optional[str]:
    """Process DOCX file and extract text content"""
    try:
        return docx2txt.process(io.BytesIO(file_data))
    except Exception as e:
        logger.error(f"Error processing DOCX: {str(e)}")
        return None

async def process_text_file(file_data: bytes) -> Optional[str]:
    """Process text file and extract content"""
    try:
        return file_data.decode('utf-8')
    except Exception as e:
        logger.error(f"Error processing text file: {str(e)}")
        return None

async def process_file(
    uploaded_file: Any,
    file_handlers: Dict[str, Any]
) -> Optional[Dict[str, Any]]:
    """Process uploaded file based on type"""
    try:
        file_data = uploaded_file.getvalue()
        content = None
        
        if uploaded_file.type == "application/pdf":
            content = await process_pdf(file_data)
        elif uploaded_file.type == "application/vnd.openxmlformats-officedocument.wordprocessingml.document":
            content = await process_docx(file_data)
        else:  # For .txt and .md files
            content = await process_text_file(file_data)
            
        if content is None:
            raise ValueError(f"Failed to process file: {uploaded_file.name}")
            
        return {
            'filename': uploaded_file.name,
            'content': content,
            'file_type': uploaded_file.type
        }
    except Exception as e:
        logger.error(f"Error processing file {uploaded_file.name}: {str(e)}")
        return None

async def analyze_documents(
    documents: List[Dict[str, Any]],
    llm_client: AsyncLLMClient,
    prompt_handler: AsyncPromptHandler,
    user_email: str
) -> Dict[str, Any]:
    """Analyze document contents using LLM"""
    try:
        # Check user authentication
        if not user_email:
            raise ValueError("User not authenticated")

        # Prepare documents for analysis
        doc_contents = [doc['content'] for doc in documents]
        doc_summary = "\n\n".join([
            f"Document: {doc['filename']}\nContent:\n{doc['content']}"
            for doc in documents
        ])
        
        # Format research prompt
        research_prompt = await prompt_handler.format_prompt(
            'topic_research',
            {
                'documents': doc_summary,
                'num_documents': len(documents)
            }
        )
        
        if not research_prompt:
            raise ValueError("Failed to format research prompt")

        # Generate analysis
        analysis = await llm_client.generate_response(
            system_prompt=(
                "You are an AI research assistant analyzing documents for "
                "Fairness Factor blog content. Focus on employee rights, "
                "workplace issues, and legal advocacy themes."
            ),
            user_prompt=research_prompt,
            max_tokens=2000,
            user_email=user_email
        )
        
        return {
            'success': True,
            'analysis': analysis,
            'document_contents': doc_contents
        }
    except Exception as e:
        logger.error(f"Error analyzing documents: {str(e)}")
        return {
            'success': False,
            'error': str(e)
        }

async def topic_research_page(db_handlers, llm_client, prompt_handler):
    """Topic Research Page Handler"""
    try:
        # Check authentication and access
        if not st.session_state.authenticated:
            st.warning("Please log in to access this page")
            st.stop()
            return
            
        if not check_page_access('Topic Research'):
            st.error("You don't have permission to access this page")
            st.stop()
            return

        user_email = st.session_state.user['email']
        
        # Log page access
        await db_handlers['analytics'].log_activity(
            user_email=user_email,
            activity_type='page_access',
            metadata={'page': 'Topic Research'}
        )

        # Existing page code continues here...
        
        st.title("Fairness Factor Blog Topic Research")
        
        # Display research guidelines
        with st.expander("Research Guidelines", expanded=True):
            st.markdown("""
            ### Document Upload Guidelines
            - Upload up to 3 research documents
            - Supported formats: PDF, DOCX, TXT, MD
            - Focus on employee rights, workplace issues, and legal advocacy
            - Documents should be relevant to Fairness Factor's mission
            
            ### Best Practices
            1. Include diverse perspectives
            2. Use recent and reliable sources
            3. Consider industry trends
            4. Focus on actionable insights
            """)
        
        # File upload section
        st.write("### Upload Research Documents")
        uploaded_files = st.file_uploader(
            "Upload up to 3 documents",
            type=["pdf", "docx", "txt", "md"],
            accept_multiple_files=True,
            key="research_files"
        )
        
        if uploaded_files:
            if len(uploaded_files) > 3:
                st.warning("‚ö†Ô∏è Please upload a maximum of 3 documents.")
                return

            processed_documents = []
            file_metadata = []
            
            # Process uploaded files
            with st.spinner("Processing documents..."):
                for uploaded_file in uploaded_files:
                    try:
                        # Process file
                        processed_file = await process_file(uploaded_file, db_handlers)
                        if processed_file:
                            processed_documents.append(processed_file)
                            
                            # Save to GridFS
                            file_id = await db_handlers['file'].save_file(
                                filename=uploaded_file.name,
                                file_data=uploaded_file.getvalue(),
                                metadata={
                                    'user_email': user_email,
                                    'file_type': uploaded_file.type,
                                    'content_type': 'research_document',
                                    'upload_date': datetime.now().isoformat()
                                }
                            )
                            
                            file_metadata.append({
                                'file_id': file_id,
                                'filename': uploaded_file.name,
                                'file_type': uploaded_file.type
                            })
                            
                    except Exception as e:
                        st.error(f"Error processing {uploaded_file.name}: {str(e)}")
                        continue
            
            # Display processed files
            if processed_documents:
                st.write("### Processed Documents")
                for doc in processed_documents:
                    with st.expander(f"üìÑ {doc['filename']}", expanded=False):
                        st.text_area(
                            "Content Preview",
                            value=doc['content'][:500] + "...",
                            height=150,
                            key=f"preview_{doc['filename']}"
                        )
                
                # Analyze documents button
                if st.button("üîç Analyze Documents"):
                    with st.spinner("Analyzing documents..."):
                        try:
                            # Analyze documents
                            result = await analyze_documents(
                                processed_documents,
                                llm_client,
                                prompt_handler,
                                user_email
                            )
                            
                            if result['success']:
                                # Save research content
                                content_id = await db_handlers['blog'].save_research(
                                    user_email=user_email,
                                    document_contents=result['document_contents'],
                                    analysis=result['analysis'],
                                    metadata={
                                        'files': file_metadata,
                                        'analysis_date': datetime.now().isoformat()
                                    }
                                )
                                
                                # Update session state
                                st.session_state['research_analysis'] = result['analysis']
                                st.session_state['research_id'] = content_id
                                st.session_state['research_files'] = file_metadata
                                
                                # Log activity
                                await db_handlers['analytics'].log_activity(
                                    user_email=user_email,
                                    activity_type='research_analysis',
                                    metadata={
                                        'content_id': content_id,
                                        'num_documents': len(processed_documents),
                                        'files': file_metadata
                                    }
                                )
                                
                                # Display results
                                st.success("‚úÖ Analysis completed successfully!")
                                st.write("### Research Analysis")
                                
                                # Display analysis in sections
                                analysis_sections = result['analysis'].split('\n\n')
                                for i, section in enumerate(analysis_sections):
                                    with st.expander(f"Section {i+1}", expanded=i==0):
                                        st.write(section)
                                        
                                        # Add section feedback
                                        feedback = st.text_area(
                                            "Section Feedback:",
                                            key=f"feedback_{i}",
                                            help="Add notes or feedback for this section"
                                        )
                                        if feedback:
                                            st.session_state.setdefault('section_feedback', {})[i] = feedback
                                
                            else:
                                st.error(f"‚ùå Analysis failed: {result.get('error', 'Unknown error')}")
                                
                        except Exception as e:
                            st.error(f"‚ùå An error occurred: {str(e)}")
                            logger.error(f"Error in topic research: {str(e)}")

        # Research history section
        with st.expander("üìö View Research History", expanded=False):
            try:
                research_history = await db_handlers['blog'].get_user_content(
                    user_email=user_email,
                    content_type='research',
                    limit=5
                )
                
                if research_history:
                    for entry in research_history:
                        col1, col2 = st.columns([3, 1])
                        with col1:
                            st.write(f"Research from {entry['created_at'].strftime('%Y-%m-%d %H:%M')}")
                        with col2:
                            if st.button(
                                "Load",
                                key=f"load_{entry['_id']}",
                                help="Load this research analysis"
                            ):
                                st.session_state['research_analysis'] = entry['analysis']
                                st.session_state['research_id'] = str(entry['_id'])
                                st.experimental_rerun()
                        st.markdown("---")
                else:
                    st.info("No previous research found.")
                    
            except Exception as e:
                st.error("Failed to load research history")
                logger.error(f"Error loading research history: {str(e)}")

    except Exception as e:
        logger.error(f"Error in topic research page: {str(e)}")
        st.error("An unexpected error occurred. Please try again.")

if __name__ == "__main__":
    # For testing the page individually
    import os
    from dotenv import load_dotenv
    
    load_dotenv()
    
    async def test_page():
        from utils.mongo_manager import AsyncMongoManager
        from utils.prompt_handler import AsyncPromptHandler
        from llm.llm_client import AsyncLLMClient
        
        mongo_manager = AsyncMongoManager()
        client, db = await mongo_manager.get_connection()
        
        handlers = {
            'blog': None,  # Add your handlers here
            'file': None,
            'analytics': None
        }
        
        await topic_research_page(
            handlers,
            AsyncLLMClient(),
            AsyncPromptHandler(db)
        )
    
    asyncio.run(test_page())

================
File: pages/user_management.py
================
# pages/user_management.py
import streamlit as st
import asyncio
from typing import Dict, Any
import logging
from datetime import datetime

logger = logging.getLogger(__name__)

async def user_management_page(db_handlers, auth_handler):
    """User Management Page"""
    if not st.session_state.authenticated or st.session_state.user.get('role') != 'admin':
        st.error("Access denied. Admin privileges required.")
        return
        
    st.title("User Management")
    
    admin_email = st.session_state.user['email']  # Get admin email from session state
    
    # Add new user form
    with st.expander("Add New User", expanded=False):
        with st.form("add_user_form"):
            new_email = st.text_input("Email", placeholder="example@fairnessfactor.com")
            new_name = st.text_input("Name")
            new_password = st.text_input("Password", type="password")
            new_role = st.selectbox("Role", ["user", "admin"])
            
            if st.form_submit_button("Add User"):
                try:
                    if await auth_handler.add_user(
                        email=new_email,
                        password=new_password,
                        name=new_name,
                        added_by=admin_email,
                        role=new_role
                    ):
                        st.success(f"User {new_email} added successfully!")
                        # Log activity
                        await db_handlers['analytics'].log_activity(
                            admin_email,
                            'user_added',
                            {'added_user': new_email}
                        )
                    else:
                        st.error("Failed to add user")
                except ValueError as ve:
                    st.error(str(ve))
                except Exception as e:
                    st.error(f"Error: {str(e)}")
    
    # List existing users
    st.write("### Existing Users")
    users = await auth_handler.get_all_users()
    
    for user in users:
        with st.expander(f"{user['name']} ({user['email']})", expanded=False):
            col1, col2, col3 = st.columns([2,1,1])
            
            with col1:
                st.write(f"**Role:** {user['role']}")
                st.write(f"**Created:** {user['created_at'].strftime('%Y-%m-%d %H:%M')}")
                st.write(f"**Last Login:** {user.get('last_login', 'Never').strftime('%Y-%m-%d %H:%M') if user.get('last_login') else 'Never'}")
            
            with col2:
                new_role = st.selectbox(
                    "Change Role",
                    ["user", "admin"],
                    index=0 if user['role'] == 'user' else 1,
                    key=f"role_{user['email']}"
                )
                if new_role != user['role']:
                    if st.button("Update Role", key=f"update_role_{user['email']}"):
                        if await auth_handler.update_user(
                            user['email'], 
                            {'role': new_role},
                            admin_email  # Pass admin email
                        ):
                            st.success(f"Role updated for {user['email']}")
                            # Log activity
                            await db_handlers['analytics'].log_activity(
                                admin_email,
                                'user_role_changed',
                                {'user': user['email'], 'new_role': new_role}
                            )
                        else:
                            st.error("Failed to update role")
            
            with col3:
                if user['email'] != admin_email:  # Prevent self-deletion
                    if st.button("Delete User", key=f"delete_{user['email']}"):
                        if await auth_handler.delete_user(
                            user['email'],
                            admin_email  # Pass admin email
                        ):
                            st.success(f"User {user['email']} deleted")
                            # Log activity
                            await db_handlers['analytics'].log_activity(
                                admin_email,
                                'user_deleted',
                                {'deleted_user': user['email']}
                            )
                            st.experimental_rerun()
                        else:
                            st.error("Failed to delete user")
                else:
                    st.write("(Current User)")
            
            # Rest of the user management page remains the same...
            
            # User Activity
            if st.button("View Activity", key=f"activity_{user['email']}"):
                activity = await auth_handler.get_user_activity(user['email'])
                if activity:
                    st.write("#### Recent Activity")
                    for entry in activity[:10]:  # Show last 10 activities
                        st.write(f"- {entry['activity_type']} on {entry['timestamp'].strftime('%Y-%m-%d %H:%M')}")
                else:
                    st.write("No recent activity")
            
            # Login History
            if st.button("View Login History", key=f"login_history_{user['email']}"):
                login_history = await auth_handler.get_login_history(user['email'])
                if login_history:
                    st.write("#### Recent Logins")
                    for entry in login_history:
                        status = "‚úÖ Success" if entry['success'] else f"‚ùå Failed ({entry.get('reason', 'Unknown')})"
                        st.write(f"- {entry['timestamp'].strftime('%Y-%m-%d %H:%M')} - {status}")
                else:
                    st.write("No login history available")

    # User Statistics
    st.write("### User Statistics")
    total_users = len(users)
    active_users = sum(1 for user in users if user.get('status') == 'active')
    admin_users = sum(1 for user in users if user.get('role') == 'admin')
    
    col1, col2, col3 = st.columns(3)
    col1.metric("Total Users", total_users)
    col2.metric("Active Users", active_users)
    col3.metric("Admin Users", admin_users)

    # Recent Activity Log
    st.write("### Recent System Activity")
    recent_activity = await db_handlers['analytics'].get_recent_activity(limit=20)
    if recent_activity:
        for activity in recent_activity:
            st.write(f"- {activity['timestamp'].strftime('%Y-%m-%d %H:%M')} - {activity['user_email']} - {activity['activity_type']}")
    else:
        st.write("No recent activity logged")

    # Export User Data
    if st.button("Export User Data"):
        user_data = [
            {
                "email": user['email'],
                "name": user['name'],
                "role": user['role'],
                "created_at": user['created_at'].isoformat(),
                "last_login": user.get('last_login', '').isoformat() if user.get('last_login') else None,
                "status": user.get('status', 'unknown')
            }
            for user in users
        ]
        st.download_button(
            label="Download User Data CSV",
            data='\n'.join([','.join(user_data[0].keys())] + [','.join(map(str, user.values())) for user in user_data]),
            file_name=f"user_data_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
            mime="text/csv"
        )

async def run_user_management_page(db_handlers, auth_handler):
    """Run the user management page"""
    try:
        await user_management_page(db_handlers, auth_handler)
    except Exception as e:
        logger.error(f"Error in user management page: {str(e)}")
        st.error("An unexpected error occurred. Please try again.")

if __name__ == "__main__":
    # For testing the page individually
    import os
    from dotenv import load_dotenv
    from utils.mongo_manager import AsyncMongoManager
    from utils.auth import AsyncAuthHandler
    
    load_dotenv()
    
    async def test_page():
        mongo_manager = AsyncMongoManager()
        client, db = await mongo_manager.get_connection()
        
        auth_handler = AsyncAuthHandler(db)
        
        handlers = {
            'analytics': None,  # Add your analytics handler here
        }
        
        await run_user_management_page(handlers, auth_handler)
    
    asyncio.run(test_page())

================
File: Procfile
================
# Procfile
web: streamlit run app.py

================
File: prompts/article_draft.txt
================
Create a comprehensive blog article draft based on:

Topic: {selected_topic}

Article Structure:
{article_structure}

Research Analysis:
{research_analysis}

Guidelines:
1. Maintain professional yet approachable tone
2. Include relevant statistics and examples
3. Highlight Fairness Factor's expertise
4. Address common employee concerns
5. Provide actionable insights
6. Include expert perspectives
7. Reference legal considerations
8. End with clear call-to-action

Key Elements:
- Engaging introduction
- Clear problem statement
- Fairness Factor's unique approach
- Benefits for employees and employers
- Real-world examples
- Practical solutions
- Expert insights
- Conclusion with next steps

Ensure content demonstrates Fairness Factor's commitment to employee advocacy while maintaining readability and engagement.

================
File: prompts/editing_criteria.txt
================
Review and provide editing suggestions for the following article:

Article Draft:
{article_draft}

Editing Criteria:
{editing_criteria}

Section-Specific Feedback:
{section_feedback}

Provide detailed suggestions for:
1. Content Enhancement
   - Clarity and coherence
   - Supporting evidence
   - Example effectiveness
   - Argument strength

2. Style Improvements
   - Tone consistency
   - Brand voice alignment
   - Language accessibility
   - Professional polish

3. Structure Optimization
   - Flow and transitions
   - Section balance
   - Information hierarchy
   - Logical progression

4. Engagement Elements
   - Reader engagement
   - Call-to-action effectiveness
   - Value proposition clarity
   - Emotional connection

Format suggestions with specific examples and recommended changes for each section.

================
File: prompts/final_article.txt
================
Generate the final version of the article incorporating:

Original Draft:
{article_draft}

Editing Suggestions:
{editing_suggestions}

Additional Feedback:
{user_feedback}

Focus on:
1. Implementing all approved edits
2. Maintaining consistent voice
3. Enhancing readability
4. Strengthening arguments
5. Polishing transitions
6. Optimizing structure
7. Reinforcing key messages
8. Perfecting call-to-action

Ensure the final article:
- Demonstrates expertise
- Engages target audience
- Provides clear value
- Maintains professional tone
- Reflects brand voice
- Drives desired action
- Supports SEO goals

================
File: prompts/image_description.txt
================
Generate image descriptions based on:

Article Content:
{article_content}

Image Type:
{image_type}

Style Preference:
{style_preference}

Additional Notes:
{additional_notes}

Provide detailed descriptions including:
1. Visual Elements
   - Composition
   - Color scheme
   - Lighting
   - Focal points

2. Subject Matter
   - Main elements
   - People representation
   - Setting/environment
   - Props/objects

3. Emotional Impact
   - Mood/atmosphere
   - Brand alignment
   - Message reinforcement
   - Viewer connection

4. Technical Specifications
   - Dimensions
   - Resolution
   - Format requirements
   - Usage considerations

Ensure descriptions align with Fairness Factor's professional image while supporting the article's message.

================
File: prompts/seo_generation.txt
================
Generate SEO optimization content for:

Article Content:
{article_content}

Image Description:
{image_description}

Target Keywords:
{target_keywords}

Provide comprehensive SEO elements:
1. Meta Information
   - Title (50-60 characters)
   - Description (150-160 characters)
   - URL slug
   - Canonical URL

2. Keyword Analysis
   - Primary keyword placement
   - Secondary keywords
   - Long-tail variations
   - LSI keywords

3. Content Optimization
   - Heading hierarchy
   - Keyword density
   - Internal linking
   - External linking

4. Schema Markup
   - Article schema
   - Organization schema
   - Author schema
   - FAQ schema (if applicable)

5. Technical SEO
   - Mobile optimization
   - Page speed considerations
   - Image alt text
   - Meta robots tags

Format response as JSON with clear sections for each element.

================
File: prompts/topic_campaign.txt
================
Based on the following research analysis:

{research_analysis}

Generate a strategic content campaign that:
1. Identifies 5-7 compelling blog topics
2. Prioritizes topics by relevance and impact
3. Suggests angles for each topic
4. Identifies target audience segments
5. Outlines potential calls-to-action

For each topic, include:
- Working title
- Key message
- Target audience
- Main pain points addressed
- Unique value proposition
- Supporting data points
- Potential expert quotes/insights
- Call-to-action suggestions

Ensure all topics align with Fairness Factor's mission of employee advocacy and workplace fairness.

================
File: prompts/topic_research.txt
================
You are analyzing research documents for Fairness Factor's blog content.

Research Documents:
{documents}

Please provide a comprehensive analysis focusing on:
1. Key themes and patterns
2. Employee advocacy opportunities
3. Workplace challenges identified
4. Potential solutions and approaches
5. Relevant statistics and data points
6. Industry trends
7. Legal considerations
8. Employee impact stories

Format your analysis with clear sections and highlight actionable insights that align with Fairness Factor's mission of employee advocacy.

Consider:
- Current workplace issues
- Employee rights and protections
- Legal precedents and regulations
- Industry best practices
- Success stories and case studies

Your analysis should help inform compelling blog content that demonstrates Fairness Factor's expertise in employee advocacy.

================
File: README.md
================
# README.md
# Fairness Factor Blog Generator

## Overview
A professional blog content generation tool built for Fairness Factor, featuring secure authentication, MongoDB integration, and automated content workflows.

## Features
- Secure authentication with domain restriction
- Content generation workflows
- MongoDB integration for data persistence
- File upload and processing
- SEO optimization tools
- User management system

## Setup
1. Clone the repository:
```bash
git clone https://github.com/yourusername/fairness-factor-blog-generator.git
cd fairness-factor-blog-generator
```

2. Create and activate virtual environment:
```bash
python -m venv venv
source venv/bin/activate  # Linux/Mac
venv\\Scripts\\activate   # Windows
```

3. Install dependencies:
```bash
pip install -r requirements.txt
```

4. Set up environment variables:
```bash
cp .env.example .env
# Edit .env with your configuration
```

5. Initialize MongoDB:
```bash
python setup_mongodb.py
```

6. Run the application:
```bash
streamlit run app.py
```

## Environment Variables
Create a `.env` file with:
```
MONGODB_URI=your_mongodb_uri
JWT_SECRET_KEY=your_jwt_secret
ANTHROPIC_API_KEY=your_anthropic_api_key
```

## Contributing
1. Fork the repository
2. Create your feature branch (`git checkout -b feature/AmazingFeature`)
3. Commit your changes (`git commit -m 'Add some AmazingFeature'`)
4. Push to the branch (`git push origin feature/AmazingFeature`)
5. Open a Pull Request

## License
Internal use only - Fairness Factor
```

```text
# packages.txt
python3-dev
build-essential
git
curl
```

```text
# requirements.txt
streamlit==1.29.0
anthropic==0.8.1
python-dotenv==1.0.0
pymongo==4.6.1
dnspython==2.4.2
bcrypt==4.1.1
PyJWT==2.8.0
pandas==2.1.3
pytest==7.4.3
pytest-cov==4.1.0
python-multipart==0.0.6
watchdog==3.0.0
python-docx==1.0.1
PyPDF2==3.0.1
```

```text
# runtime.txt
python-3.9.16
```

================
File: requirements.txt
================
# requirements.txt
streamlit==1.29.0
anthropic==0.8.1
python-dotenv==1.0.0
motor==3.3.2
pymongo==4.6.1
dnspython==2.4.2
bcrypt==4.1.1
PyJWT==2.8.0
pandas==2.1.3
pytest==7.4.3
pytest-cov==4.1.0
python-multipart==0.0.6
watchdog==3.0.0
python-docx==1.0.1
PyPDF2==3.0.1
docx2txt2==1.0.4
Pillow==10.0.0
pyyaml==6.0.1
nest_asyncio==1.6.0

================
File: scripts/rotate_jwt_key.py
================
# scripts/rotate_jwt_key.py
import asyncio
import os
from dotenv import load_dotenv
from utils.mongo_manager import AsyncMongoManager
from utils.key_rotation import JWTKeyRotator
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

async def rotate_jwt_key():
    """Rotate JWT key and update environment"""
    try:
        # Initialize MongoDB connection
        mongo_manager = AsyncMongoManager()
        async with mongo_manager.get_connection() as (_, db, _):
            key_rotator = JWTKeyRotator(db)
            
            # Rotate key
            new_key_data = await key_rotator.rotate_key()
            
            # Update .env file
            env_path = '.env'
            temp_env_path = '.env.temp'
            
            with open(env_path, 'r') as env_file:
                env_contents = env_file.readlines()
            
            with open(temp_env_path, 'w') as temp_file:
                for line in env_contents:
                    if line.startswith('JWT_SECRET_KEY='):
                        temp_file.write(f'JWT_SECRET_KEY={new_key_data["key"]}\n')
                    else:
                        temp_file.write(line)
            
            # Replace old .env with new one
            os.replace(temp_env_path, env_path)
            
            # Clean up expired keys
            deleted_count = await key_rotator.cleanup_expired_keys()
            
            logger.info(f"JWT key rotated successfully. Expires: {new_key_data['expires_at']}")
            logger.info(f"Cleaned up {deleted_count} expired keys")
            
    except Exception as e:
        logger.error(f"Error rotating JWT key: {e}")
        raise

if __name__ == "__main__":
    load_dotenv()
    asyncio.run(rotate_jwt_key())

================
File: static/styles.css
================
/* static/styles.css */
:root {
    /* Primary Color Palette */
    --white: #ffffff;
    --black: #000000;
    --accent-orange: #FC510B;
    --dark-orange: #FF7500;
    --deep-orange: #FF5722;
    --primary-blue: #0075E0;
    --secondary-blue: #003A6E;
    --overlay-color: #CEF3FF;
    
    /* Global Colors */
    --accent-color-1: var(--e-global-color-ee3daea);
    --accent-color-2: var(--e-global-color-b2c6ea4);
}

/* Main app styling */
.stApp {
    background: linear-gradient(135deg, var(--primary-blue) 0%, var(--secondary-blue) 100%);
    color: var(--white);
}

/* Header styles */
.stApp > header {
    position: fixed;
    top: 0;
    z-index: 100;
    transition: background-color 0.3s ease;
}

.stApp > header.sticky {
    background-color: var(--white);
}

/* Logo containers */
.logo-container-login, .logo-container-main {
    text-align: center;
    padding: 1.5rem 0;
    margin-bottom: 2rem;
    transition: transform 0.3s ease;
}

.logo-container-login img,
.logo-container-main img {
    max-width: 240px;
    height: auto;
    transition: transform 0.3s ease;
}

/* Typography & Text Styles */
h1, h2, h3, h4, h5, h6 {
    font-weight: 700;
    color: var(--white);
}

.accent-color {
    color: var(--accent-orange);
}

/* Breadcrumbs */
.breadcrumb {
    display: flex;
    gap: 0.5rem;
    align-items: center;
}

.breadcrumb-item {
    color: var(--accent-orange);
    text-decoration: none;
}

.breadcrumb-item.active {
    color: var(--white);
}

/* Buttons */
.stButton > button {
    background-color: var(--accent-orange) !important;
    color: var(--white) !important;
    border: none !important;
    border-radius: 4px !important;
    padding: 0.75rem 1.5rem !important;
    font-weight: 600 !important;
    transition: all 0.3s ease !important;
}

.stButton > button:hover {
    background-color: var(--primary-blue) !important;
    transform: translateY(-1px);
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

/* Mission Section */
.mission-section {
    position: relative;
    overflow: hidden;
}

.mission-section::before {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: radial-gradient(circle at center, var(--overlay-color) 0%, transparent 70%);
    opacity: 0.1;
    pointer-events: none;
}

/* Cards */
.content-card {
    background: linear-gradient(135deg, var(--primary-blue) 0%, transparent 100%);
    padding: 2rem;
    border-radius: 8px;
    margin-bottom: 1.5rem;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

/* Form elements */
.stTextInput > div > div > input {
    border: 2px solid var(--accent-orange) !important;
    border-radius: 4px;
    padding: 0.75rem 1rem;
    transition: all 0.3s ease;
}

.stTextInput > div > div > input:focus {
    border-color: var(--primary-blue) !important;
    box-shadow: 0 0 0 2px rgba(0, 117, 224, 0.2);
}

/* Navigation items */
.nav-item {
    position: relative;
    padding: 0.5rem 1rem;
    transition: all 0.3s ease;
}

.nav-item:hover::before {
    content: "‚Ä¢";
    color: var(--accent-orange);
    position: absolute;
    left: -0.5rem;
}

/* Newsletter & Subscription Forms */
.newsletter-form {
    background-color: var(--white);
    padding: 2rem;
    border-radius: 8px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

.newsletter-form button {
    background-color: var(--accent-orange);
    transition: background-color 0.3s ease;
}

.newsletter-form button:hover {
    background-color: var(--primary-blue);
}

/* Responsive adjustments */
@media screen and (max-width: 1036px) {
    .newsletter-form {
        display: flex;
        flex-direction: column;
        gap: 1rem;
    }

    .stButton > button {
        padding: 0.5rem 1rem !important;
    }

    .logo-container-login img,
    .logo-container-main img {
        max-width: 180px;
    }
}

/* User welcome message */
.user-welcome {
    color: var(--white);
    font-size: 1.1rem;
    padding: 1rem;
    margin-bottom: 1rem;
    text-align: center;
    font-weight: 500;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 6px;
}

/* Page headers */
.page-header {
    color: var(--white);
    font-size: 2rem;
    font-weight: 700;
    margin: 1rem 0 2rem 0;
    padding-bottom: 1rem;
    border-bottom: 2px solid rgba(255, 255, 255, 0.1);
}

/* Footer */
.footer {
    text-align: center;
    padding: 2rem 0;
    margin-top: 4rem;
    border-top: 1px solid rgba(255, 255, 255, 0.1);
}

.footer p {
    color: var(--white);
    opacity: 0.8;
    font-size: 0.9rem;
}

/* Custom scrollbar */
::-webkit-scrollbar {
    width: 8px;
}

::-webkit-scrollbar-track {
    background: var(--secondary-blue);
}

::-webkit-scrollbar-thumb {
    background: var(--accent-orange);
    border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
    background: var(--dark-orange);
}

/* Feature list */
.feature-list li::before {
    content: "‚Ä¢";
    color: var(--deep-orange);
    font-weight: bold;
    display: inline-block;
    width: 1em;
    margin-left: -1em;
}

/* Loading spinner */
.stSpinner {
    border-color: var(--accent-orange) !important;
}

================
File: test_auth.py
================
import asyncio
from motor.motor_asyncio import AsyncIOMotorClient
from urllib.parse import quote_plus
import logging
from dotenv import load_dotenv
import os

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

async def test_auth_levels():
    """Test MongoDB authentication with different permission levels"""
    try:
        load_dotenv()
        uri = os.getenv('MONGODB_URI')
        
        if not uri:
            logger.error("MongoDB URI not found in environment variables")
            return False
            
        logger.info("Testing connection with provided URI...")
        logger.info(f"URI format check: {uri.split('://')[0]}://<credentials>@{uri.split('@')[1]}")
        
        client = AsyncIOMotorClient(uri)
        db = client.fairness_factor_blog
        
        # Test 1: Basic Connection
        logger.info("\nTest 1: Testing basic connection...")
        try:
            await client.admin.command('ping')
            logger.info("‚úÖ Basic connection successful")
        except Exception as e:
            logger.error(f"‚ùå Basic connection failed: {str(e)}")
            return False
            
        # Test 2: Read Permission
        logger.info("\nTest 2: Testing read permission...")
        try:
            collections = await db.list_collection_names()
            logger.info(f"‚úÖ Read permission verified. Found collections: {collections}")
        except Exception as e:
            logger.error(f"‚ùå Read permission failed: {str(e)}")
            
        # Test 3: Write Permission
        logger.info("\nTest 3: Testing write permission...")
        try:
            result = await db.test_collection.insert_one({"test": "data"})
            logger.info("‚úÖ Write permission verified")
            await db.test_collection.delete_one({"test": "data"})
        except Exception as e:
            logger.error(f"‚ùå Write permission failed: {str(e)}")
            
        # Test 4: Index Creation
        logger.info("\nTest 4: Testing index creation permission...")
        try:
            await db.test_collection.create_index([("test_field", 1)])
            logger.info("‚úÖ Index creation permission verified")
        except Exception as e:
            logger.error(f"‚ùå Index creation failed: {str(e)}")
            
        logger.info("\nPermission test summary:")
        logger.info("Please ensure your MongoDB user has:")
        logger.info("1. readWrite role on the database")
        logger.info("2. dbAdmin role for index management")
        logger.info("\nTo fix permissions in MongoDB Atlas:")
        logger.info("1. Go to Database Access")
        logger.info("2. Edit user 'KrypticGadget'")
        logger.info("3. Add 'readWrite' and 'dbAdmin' roles for database 'fairness_factor_blog'")
        
        return True
        
    except Exception as e:
        logger.error(f"‚ùå Overall test failed: {str(e)}")
        return False
        
    finally:
        if 'client' in locals():
            client.close()

if __name__ == "__main__":
    asyncio.run(test_auth_levels())

================
File: test_mongodb_connection.py
================
import asyncio
from motor.motor_asyncio import AsyncIOMotorClient
from urllib.parse import quote_plus
import logging
from dotenv import load_dotenv
import os

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

async def test_mongodb_connection():
    """Test MongoDB connection with updated URI format"""
    try:
        # Connection parameters
        username = "KrypticGadget"
        password = "1629609804"  # In production, get from environment
        cluster = "fairness-factor-cluster.p0tsa.mongodb.net"
        
        # Properly escape credentials
        username = quote_plus(username)
        password = quote_plus(password)
        
        # Construct URI with updated format
        uri = f"mongodb+srv://{username}:{password}@{cluster}/?retryWrites=true&w=majority&appName=fairness-factor-cluster"
        
        logger.info("Testing connection with new URI format...")
        client = AsyncIOMotorClient(uri)
        
        # Test basic connection
        logger.info("Testing basic connection...")
        await client.admin.command('ping')
        logger.info("‚úÖ Basic connection successful!")
        
        # Select database
        db = client.fairness_factor_blog
        logger.info("Selecting database: fairness_factor_blog")
        
        # Test database operations
        logger.info("Testing database operations...")
        try:
            # Test read
            collections = await db.list_collection_names()
            logger.info(f"üìö Existing collections: {collections}")
            
            # Test write
            result = await db.connection_test.insert_one({"test": "data"})
            logger.info("‚úÖ Write test successful")
            await db.connection_test.delete_one({"test": "data"})
            logger.info("‚úÖ Delete test successful")
            
            # Test index creation
            await db.connection_test.create_index([("test_field", 1)])
            logger.info("‚úÖ Index creation successful")
            
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Database operation failed: {str(e)}")
            logger.info("\nTroubleshooting steps:")
            logger.info("1. Verify user permissions in MongoDB Atlas")
            logger.info("2. Check database name is correct")
            logger.info("3. Ensure IP whitelist includes your current IP")
            return False
            
    except Exception as e:
        logger.error(f"‚ùå Connection failed: {str(e)}")
        return False
        
    finally:
        if 'client' in locals():
            client.close()

if __name__ == "__main__":
    asyncio.run(test_mongodb_connection())

================
File: test_mongodb.py
================
import asyncio
from motor.motor_asyncio import AsyncIOMotorClient
import logging
from dotenv import load_dotenv
import os

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

async def test_connection():
    """Test MongoDB connection"""
    try:
        load_dotenv()
        uri = os.getenv('MONGODB_URI')
        
        if not uri:
            logger.error("MongoDB URI not found in environment variables")
            return False
            
        client = AsyncIOMotorClient(uri)
        
        # Test connection
        await client.admin.command('ping')
        logger.info("‚úÖ Successfully connected to MongoDB!")
        
        # Get database
        db = client.fairness_factor_blog
        
        # List collections
        collections = await db.list_collection_names()
        logger.info(f"üìö Available collections: {collections}")
        
        return True
        
    except Exception as e:
        logger.error(f"‚ùå Connection error: {str(e)}")
        return False
    
    finally:
        if 'client' in locals():
            client.close()

# For direct script execution
if __name__ == "__main__":
    asyncio.run(test_connection())

================
File: tests/test_mongodb.py
================
# tests/test_mongodb.py
import pytest
from unittest.mock import Mock, patch
import os
from datetime import datetime
from bson import ObjectId
from utils.mongo_manager import MongoManager, get_db_context
from utils.data_handlers import BlogContentHandler, FileHandler, SessionHandler, AnalyticsHandler

@pytest.fixture
def mock_mongo_client():
    with patch('pymongo.MongoClient') as mock_client:
        mock_db = Mock()
        mock_fs = Mock()
        mock_client.return_value.fairness_factor_blog = mock_db
        mock_client.return_value.admin.command = Mock()
        yield mock_client, mock_db, mock_fs

@pytest.fixture
def mock_db_context(mock_mongo_client):
    mock_client, mock_db, mock_fs = mock_mongo_client
    with patch('utils.mongo_manager.MongoManager') as mock_manager:
        mock_manager.return_value.get_connection.return_value = (mock_client, mock_db, mock_fs)
        yield mock_db

class TestMongoManager:
    def test_singleton_instance(self):
        manager1 = MongoManager()
        manager2 = MongoManager()
        assert manager1 is manager2

    def test_connection_error_handling(self, mock_mongo_client):
        mock_client, _, _ = mock_mongo_client
        mock_client.side_effect = Exception("Connection failed")
        
        with pytest.raises(Exception) as exc_info:
            MongoManager()
        assert "Connection failed" in str(exc_info.value)

class TestBlogContentHandler:
    @pytest.fixture
    def blog_handler(self, mock_db_context):
        return BlogContentHandler(mock_db_context)

    def test_save_research(self, blog_handler, mock_db_context):
        mock_db_context.blog_content.insert_one.return_value = Mock(inserted_id=ObjectId())
        
        result = blog_handler.save_research(
            user_email="test@fairnessfactor.com",
            document_contents=["test content"],
            analysis="test analysis"
        )
        
        assert isinstance(result, str)
        assert mock_db_context.blog_content.insert_one.called

    def test_get_user_content(self, blog_handler, mock_db_context):
        expected_content = [{"_id": ObjectId(), "content": "test"}]
        mock_db_context.blog_content.find.return_value.sort.return_value = expected_content
        
        result = blog_handler.get_user_content("test@fairnessfactor.com")
        
        assert result == expected_content
        assert mock_db_context.blog_content.find.called

# Add more test classes and methods as needed

================
File: utils/__init__.py
================
# utils/__init__.py
from .auth import AsyncAuthHandler
from .mongo_manager import AsyncMongoManager
from .data_handlers import AsyncBlogContentHandler, AsyncFileHandler, AsyncAnalyticsHandler
from .prompt_handler import AsyncPromptHandler
from .session_manager import AsyncSessionManager

__all__ = [
    'AsyncAuthHandler',
    'AsyncMongoManager',
    'AsyncBlogContentHandler',
    'AsyncFileHandler',
    'AsyncAnalyticsHandler',
    'AsyncPromptHandler',
    'AsyncSessionManager'
]

================
File: utils/auth_handler.py
================
# utils/auth_handler.py
import os
import jwt
import bcrypt
from datetime import datetime, timedelta
import logging
from typing import Optional, Dict, Any, List
import asyncio
from motor.motor_asyncio import AsyncIOMotorDatabase
from bson import ObjectId

logger = logging.getLogger(__name__)

class AsyncAuthHandler:
    """Handles user authentication and management"""
    
    def __init__(self, db: AsyncIOMotorDatabase):
        self.secret_key = os.getenv('JWT_SECRET_KEY')
        if not self.secret_key:
            raise ValueError("JWT_SECRET_KEY not found in environment variables")
        self.db = db
        self.users_collection = db.users
        self.login_history_collection = db.login_history
        asyncio.create_task(self._ensure_indexes())
        asyncio.create_task(self._ensure_admin_user())

    async def delete_user(self, email: str, admin_email: str) -> bool:
        """Delete a user"""
        try:
            # Don't allow deletion of the last admin user
            if email.lower() == os.getenv('ADMIN_EMAIL', 'admin@fairnessfactor.com').lower():
                admin_count = await self.users_collection.count_documents({'role': 'admin'})
                if admin_count <= 1:
                    raise ValueError("Cannot delete the last admin user")

            result = await self.users_collection.delete_one({'email': email.lower()})
            
            if result.deleted_count > 0:
                # Log user deletion
                await self.db.user_activity.insert_one({
                    'user_email': email.lower(),
                    'activity_type': 'user_deleted',
                    'deleted_by': admin_email,  # Use passed admin email instead of session state
                    'timestamp': datetime.now()
                })
                return True
            return False
            
        except Exception as e:
            logger.error(f"Error deleting user {email}: {str(e)}")
            return False

    async def update_user(
        self, 
        email: str, 
        updates: Dict[str, Any],
        admin_email: str  # Add admin_email parameter
    ) -> bool:
        """Update user information"""
        try:
            # Don't allow role change for the last admin
            if 'role' in updates and email.lower() == os.getenv('ADMIN_EMAIL', '').lower():
                admin_count = await self.users_collection.count_documents({'role': 'admin'})
                if admin_count <= 1 and updates['role'] != 'admin':
                    raise ValueError("Cannot change role of the last admin user")

            result = await self.users_collection.update_one(
                {'email': email.lower()},
                {'$set': {
                    **updates,
                    'updated_at': datetime.now()
                }}
            )
            
            if result.modified_count > 0:
                # Log user update
                await self.db.user_activity.insert_one({
                    'user_email': email.lower(),
                    'activity_type': 'user_updated',
                    'updated_by': admin_email,  # Use passed admin email instead of session state
                    'updates': updates,
                    'timestamp': datetime.now()
                })
                return True
            return False
            
        except Exception as e:
            logger.error(f"Error updating user {email}: {str(e)}")
            return False

    # ... [rest of the existing methods remain the same]

    async def _ensure_indexes(self):
        """Create necessary database indexes"""
        try:
            await self.users_collection.create_index([("email", 1)], unique=True)
            await self.users_collection.create_index([("created_at", -1)])
            await self.login_history_collection.create_index([("user_email", 1)])
            await self.login_history_collection.create_index([("timestamp", -1)])
            logger.info("Auth indexes created successfully")
        except Exception as e:
            logger.error(f"Error creating auth indexes: {str(e)}")

    async def _ensure_admin_user(self):
        """Ensure admin user exists"""
        try:
            admin_email = os.getenv('ADMIN_EMAIL', 'admin@fairnessfactor.com')
            admin_password = os.getenv('ADMIN_PASSWORD', '1122Kryptic$')
            
            admin_exists = await self.users_collection.find_one({'email': admin_email})
            if not admin_exists:
                salt = bcrypt.gensalt()
                hashed_password = bcrypt.hashpw(admin_password.encode('utf-8'), salt)
                
                await self.users_collection.insert_one({
                    'email': admin_email,
                    'password': hashed_password,
                    'name': 'Admin User',
                    'role': 'admin',
                    'created_at': datetime.now(),
                    'created_by': 'system',
                    'last_login': None,
                    'status': 'active'
                })
                logger.info("Created default admin user")
        except Exception as e:
            logger.error(f"Error ensuring admin user: {str(e)}")

    async def verify_email_domain(self, email: str) -> bool:
        """Verify email belongs to Fairness Factor domain."""
        try:
            email = email.lower()
            allowed_domains = ['fairnessfactor.com']
            domain = email.split('@')[-1]
            return domain in allowed_domains
        except Exception as e:
            logger.error(f"Email verification error: {str(e)}")
            return False

    async def add_user(
        self, 
        email: str, 
        password: str, 
        name: str, 
        added_by: str, 
        role: str = 'user'
    ) -> bool:
        """Add a new user to the system."""
        try:
            if not await self.verify_email_domain(email):
                raise ValueError("Only Fairness Factor email addresses are allowed")

            existing_user = await self.users_collection.find_one({'email': email.lower()})
            if existing_user:
                raise ValueError("User already exists")

            # Get current event loop
            loop = asyncio.get_running_loop()
            
            # Run bcrypt operations in executor
            salt = await loop.run_in_executor(None, bcrypt.gensalt)
            hashed = await loop.run_in_executor(
                None, 
                bcrypt.hashpw, 
                password.encode('utf-8'), 
                salt
            )

            await self.users_collection.insert_one({
                'email': email.lower(),
                'password': hashed,
                'name': name,
                'role': role,
                'created_at': datetime.now(),
                'created_by': added_by,
                'last_login': None,
                'status': 'active',
                'failed_login_attempts': 0,
                'last_password_change': datetime.now()
            })
            
            # Log user creation
            await self.db.user_activity.insert_one({
                'user_email': email.lower(),
                'activity_type': 'user_created',
                'created_by': added_by,
                'timestamp': datetime.now()
            })
            
            return True

        except Exception as e:
            logger.error(f"Error adding user {email}: {str(e)}")
            raise

    async def login(self, email: str, password: str) -> Optional[str]:
        """Authenticate user and return JWT token."""
        try:
            user = await self.users_collection.find_one({'email': email.lower()})
            if not user:
                await self._log_failed_login(email, 'user_not_found')
                return None

            if user.get('status') != 'active':
                await self._log_failed_login(email, 'account_inactive')
                return None

            # Check failed login attempts
            if user.get('failed_login_attempts', 0) >= 5:
                last_attempt = user.get('last_failed_login')
                if last_attempt and (datetime.now() - last_attempt).total_seconds() < 1800:  # 30 minutes
                    await self._log_failed_login(email, 'account_locked')
                    return None

            # Get current event loop
            loop = asyncio.get_running_loop()

            stored_password = user['password']
            if isinstance(stored_password, str):
                stored_password = stored_password.encode('utf-8')

            # Run password check in executor
            is_valid = await loop.run_in_executor(
                None,
                bcrypt.checkpw,
                password.encode('utf-8'),
                stored_password
            )

            if is_valid:
                # Reset failed login attempts
                await self.users_collection.update_one(
                    {'email': email.lower()},
                    {
                        '$set': {
                            'failed_login_attempts': 0,
                            'last_login': datetime.now()
                        }
                    }
                )

                # Generate token
                token = jwt.encode({
                    'email': user['email'],
                    'name': user['name'],
                    'role': user.get('role', 'user'),
                    'exp': datetime.utcnow() + timedelta(days=1)
                }, self.secret_key, algorithm='HS256')

                # Log successful login
                await self.login_history_collection.insert_one({
                    'user_email': user['email'],
                    'timestamp': datetime.now(),
                    'success': True,
                    'ip_address': None,  # Could be added if needed
                    'user_agent': None   # Could be added if needed
                })

                return token

            # Handle failed login
            await self._handle_failed_login(email)
            return None

        except Exception as e:
            logger.error(f"Login error for {email}: {str(e)}")
            return None

    async def _handle_failed_login(self, email: str):
        """Handle failed login attempt"""
        try:
            await self.users_collection.update_one(
                {'email': email.lower()},
                {
                    '$inc': {'failed_login_attempts': 1},
                    '$set': {'last_failed_login': datetime.now()}
                }
            )
            await self._log_failed_login(email, 'invalid_password')
        except Exception as e:
            logger.error(f"Error handling failed login: {str(e)}")

    async def _log_failed_login(self, email: str, reason: str):
        """Log failed login attempt"""
        try:
            await self.login_history_collection.insert_one({
                'user_email': email,
                'timestamp': datetime.now(),
                'success': False,
                'reason': reason
            })
        except Exception as e:
            logger.error(f"Error logging failed login: {str(e)}")

    async def verify_token(self, token: str) -> Optional[Dict[str, Any]]:
        """Verify JWT token and return user info."""
        try:
            # Get current event loop
            loop = asyncio.get_running_loop()
            
            # Run JWT decode in executor
            payload = await loop.run_in_executor(
                None,
                jwt.decode,
                token,
                self.secret_key,
                algorithms=['HS256']
            )
            
            user = await self.users_collection.find_one({'email': payload['email']})
            if user and user.get('status') == 'active':
                return {
                    'email': user['email'],
                    'name': user['name'],
                    'role': user.get('role', 'user')
                }
            return None

        except jwt.ExpiredSignatureError:
            logger.warning("Token expired")
            return None
        except jwt.InvalidTokenError:
            logger.warning("Invalid token")
            return None
        except Exception as e:
            logger.error(f"Token verification error: {str(e)}")
            return None

    async def get_all_users(self) -> List[Dict[str, Any]]:
        """Get all users"""
        try:
            cursor = self.users_collection.find(
                {},
                {
                    'password': 0,
                    'failed_login_attempts': 0,
                    'last_failed_login': 0
                }
            ).sort('created_at', -1)
            return await cursor.to_list(length=None)
        except Exception as e:
            logger.error(f"Error getting users: {str(e)}")
            return []

    async def delete_user(self, email: str) -> bool:
        """Delete a user"""
        try:
            # Don't allow deletion of the last admin user
            if email.lower() == os.getenv('ADMIN_EMAIL', 'admin@fairnessfactor.com').lower():
                admin_count = await self.users_collection.count_documents({'role': 'admin'})
                if admin_count <= 1:
                    raise ValueError("Cannot delete the last admin user")

            result = await self.users_collection.delete_one({'email': email.lower()})
            
            if result.deleted_count > 0:
                # Log user deletion
                await self.db.user_activity.insert_one({
                    'user_email': email.lower(),
                    'activity_type': 'user_deleted',
                    'deleted_by': st.session_state.user['email'],
                    'timestamp': datetime.now()
                })
                return True
            return False
            
        except Exception as e:
            logger.error(f"Error deleting user {email}: {str(e)}")
            return False

    async def update_user(
        self, 
        email: str, 
        updates: Dict[str, Any]
    ) -> bool:
        """Update user information"""
        try:
            # Don't allow role change for the last admin
            if 'role' in updates and email.lower() == os.getenv('ADMIN_EMAIL').lower():
                admin_count = await self.users_collection.count_documents({'role': 'admin'})
                if admin_count <= 1 and updates['role'] != 'admin':
                    raise ValueError("Cannot change role of the last admin user")

            result = await self.users_collection.update_one(
                {'email': email.lower()},
                {'$set': {
                    **updates,
                    'updated_at': datetime.now()
                }}
            )
            
            if result.modified_count > 0:
                # Log user update
                await self.db.user_activity.insert_one({
                    'user_email': email.lower(),
                    'activity_type': 'user_updated',
                    'updated_by': st.session_state.user['email'],
                    'updates': updates,
                    'timestamp': datetime.now()
                })
                return True
            return False
            
        except Exception as e:
            logger.error(f"Error updating user {email}: {str(e)}")
            return False

    async def change_password(
        self, 
        email: str, 
        current_password: str, 
        new_password: str
    ) -> bool:
        """Change user password"""
        try:
            user = await self.users_collection.find_one({'email': email.lower()})
            if not user:
                return False

            # Get current event loop
            loop = asyncio.get_running_loop()

            # Verify current password
            is_valid = await loop.run_in_executor(
                None,
                bcrypt.checkpw,
                current_password.encode('utf-8'),
                user['password']
            )

            if not is_valid:
                return False

            # Hash new password
            salt = await loop.run_in_executor(None, bcrypt.gensalt)
            new_hash = await loop.run_in_executor(
                None,
                bcrypt.hashpw,
                new_password.encode('utf-8'),
                salt
            )

            # Update password
            result = await self.users_collection.update_one(
                {'email': email.lower()},
                {
                    '$set': {
                        'password': new_hash,
                        'last_password_change': datetime.now()
                    }
                }
            )

            if result.modified_count > 0:
                # Log password change
                await self.db.user_activity.insert_one({
                    'user_email': email.lower(),
                    'activity_type': 'password_changed',
                    'timestamp': datetime.now()
                })
                return True
            return False

        except Exception as e:
            logger.error(f"Error changing password for {email}: {str(e)}")
            return False

    async def get_user_activity(
        self, 
        email: str,
        limit: int = 50
    ) -> List[Dict[str, Any]]:
        """Get user activity history"""
        try:
            cursor = self.db.user_activity.find(
                {'user_email': email.lower()}
            ).sort('timestamp', -1).limit(limit)
            return await cursor.to_list(length=None)
        except Exception as e:
            logger.error(f"Error retrieving user activity: {str(e)}")
            return []

    async def get_login_history(
        self, 
        email: str,
        limit: int = 10
    ) -> List[Dict[str, Any]]:
        """Get user login history"""
        try:
            cursor = self.login_history_collection.find(
                {'user_email': email.lower()}
            ).sort('timestamp', -1).limit(limit)
            return await cursor.to_list(length=None)
        except Exception as e:
            logger.error(f"Error retrieving login history: {str(e)}")
            return []

================
File: utils/auth.py
================
# utils/auth.py
import os
import asyncio
from datetime import datetime, timedelta
import logging
import jwt
import bcrypt
from motor.motor_asyncio import AsyncIOMotorDatabase
from typing import Optional, Dict, Any, List
from dotenv import load_dotenv

load_dotenv()

logger = logging.getLogger(__name__)

class AsyncAuthHandler:
    def __init__(self, db: AsyncIOMotorDatabase):
        self.db = db
        self.secret_key = os.getenv('JWT_SECRET_KEY')
        if not self.secret_key:
            raise ValueError("JWT_SECRET_KEY not found in environment variables")
        self.users_collection = db.users
        self.login_history_collection = db.login_history

    async def verify_email_domain(self, email: str) -> bool:
        """Verify email belongs to Fairness Factor domain."""
        return email.lower().endswith('@fairnessfactor.com')

    async def add_user(
        self,
        email: str,
        password: str,
        name: str,
        added_by: str,
        role: str = 'user'
    ) -> bool:
        """Add a new user to the system."""
        try:
            if not await self.verify_email_domain(email):
                raise ValueError("Only Fairness Factor email addresses are allowed")

            existing_user = await self.users_collection.find_one({'email': email.lower()})
            if existing_user:
                raise ValueError("User already exists")

            # Get current event loop
            loop = asyncio.get_running_loop()
            
            # Run bcrypt operations in executor
            salt = await loop.run_in_executor(None, bcrypt.gensalt)
            hashed = await loop.run_in_executor(None, bcrypt.hashpw, password.encode('utf-8'), salt)

            await self.users_collection.insert_one({
                'email': email.lower(),
                'password': hashed,
                'name': name,
                'role': role,
                'created_at': datetime.now(),
                'created_by': added_by
            })
            return True
        except Exception as e:
            logger.error(f"Error adding user {email}: {str(e)}")
            raise

    async def login(self, email: str, password: str) -> Optional[str]:
        """Authenticate user and return JWT token."""
        try:
            # Get current event loop
            loop = asyncio.get_running_loop()
            
            user = await self.users_collection.find_one({'email': email.lower()})
            if not user:
                return None

            stored_password = user['password']
            if isinstance(stored_password, str):
                stored_password = stored_password.encode('utf-8')

            # Run password check in executor to avoid blocking
            is_valid = await loop.run_in_executor(
                None, 
                bcrypt.checkpw,
                password.encode('utf-8'),
                stored_password
            )

            if is_valid:
                token = jwt.encode({
                    'email': user['email'],
                    'name': user['name'],
                    'role': user.get('role', 'user'),
                    'exp': datetime.utcnow() + timedelta(days=1)
                }, self.secret_key, algorithm='HS256')

                # Log successful login
                await self.login_history_collection.insert_one({
                    'user_email': user['email'],
                    'timestamp': datetime.now(),
                    'success': True
                })
                return token

            # Log failed login
            await self.login_history_collection.insert_one({
                'user_email': email,
                'timestamp': datetime.now(),
                'success': False,
                'reason': 'invalid_password'
            })
            return None

        except Exception as e:
            logger.error(f"Login error for {email}: {str(e)}")
            return None

    async def verify_token(self, token: str) -> Optional[Dict[str, Any]]:
        """Verify JWT token and return user info."""
        try:
            # Get current event loop
            loop = asyncio.get_running_loop()
            
            # Run JWT decode in executor
            payload = await loop.run_in_executor(
                None,
                jwt.decode,
                token,
                self.secret_key,
                algorithms=['HS256']
            )
            
            user = await self.users_collection.find_one({'email': payload['email']})
            if user:
                return {
                    'email': user['email'],
                    'name': user['name'],
                    'role': user.get('role', 'user')
                }
            return None
        except jwt.ExpiredSignatureError:
            logger.warning("Token expired")
            return None
        except jwt.InvalidTokenError:
            logger.warning("Invalid token")
            return None
        except Exception as e:
            logger.error(f"Token verification error: {str(e)}")
            return None

    async def get_user_sessions(self, user_email: str) -> List[Dict[str, Any]]:
        """Get user's session history"""
        try:
            cursor = self.login_history_collection.find(
                {'user_email': user_email}
            ).sort('timestamp', -1).limit(10)
            return await cursor.to_list(length=None)
        except Exception as e:
            logger.error(f"Error retrieving user sessions: {str(e)}")
            return []

    async def get_user(self, email: str) -> Optional[Dict[str, Any]]:
        """Get user information."""
        try:
            user = await self.users_collection.find_one({'email': email.lower()})
            if user:
                return {
                    'email': user['email'],
                    'name': user['name'],
                    'role': user.get('role', 'user'),
                    'created_at': user['created_at']
                }
            return None
        except Exception as e:
            logger.error(f"Error retrieving user {email}: {str(e)}")
            return None

    async def change_password(self, email: str, current_password: str, new_password: str) -> bool:
        """Change user password."""
        try:
            # Get current event loop
            loop = asyncio.get_running_loop()
            
            user = await self.users_collection.find_one({'email': email.lower()})
            if not user:
                return False

            stored_password = user['password']
            if isinstance(stored_password, str):
                stored_password = stored_password.encode('utf-8')

            # Run password check in executor
            is_valid = await loop.run_in_executor(
                None,
                bcrypt.checkpw,
                current_password.encode('utf-8'),
                stored_password
            )

            if is_valid:
                # Generate new password hash in executor
                salt = await loop.run_in_executor(None, bcrypt.gensalt)
                new_hashed = await loop.run_in_executor(
                    None,
                    bcrypt.hashpw,
                    new_password.encode('utf-8'),
                    salt
                )
                
                result = await self.users_collection.update_one(
                    {'email': email.lower()},
                    {'$set': {'password': new_hashed}}
                )
                return result.modified_count > 0
            return False
        except Exception as e:
            logger.error(f"Password change error for {email}: {str(e)}")
            return False

================
File: utils/data_handlers.py
================
# utils/data_handlers.py
from datetime import datetime
from bson import ObjectId
import logging
from typing import Optional, List, Dict, Any
import pandas as pd
import io
import asyncio

logger = logging.getLogger(__name__)

class AsyncBlogContentHandler:
    def __init__(self, db):
        self.db = db
        self.collection = db.blog_content

    async def save_research(self, user_email: str, document_contents: List[str], analysis: str) -> str:
        try:
            document = {
                'type': 'research',
                'user_email': user_email,
                'document_contents': document_contents,
                'analysis': analysis,
                'created_at': datetime.now(),
                'updated_at': datetime.now()
            }
            result = await self.collection.insert_one(document)
            return str(result.inserted_id)
        except Exception as e:
            logger.error(f"Error saving research: {e}")
            raise

    async def save_article_draft(
        self, 
        user_email: str, 
        research_id: str, 
        content: str, 
        metadata: Dict[str, Any]
    ) -> str:
        try:
            document = {
                'type': 'draft',
                'user_email': user_email,
                'research_id': research_id,
                'content': content,
                'metadata': metadata,
                'created_at': datetime.now(),
                'updated_at': datetime.now()
            }
            result = await self.collection.insert_one(document)
            return str(result.inserted_id)
        except Exception as e:
            logger.error(f"Error saving article draft: {e}")
            raise

    async def get_user_content(
        self, 
        user_email: str, 
        content_type: Optional[str] = None,
        limit: int = 100
    ) -> List[Dict]:
        try:
            query = {'user_email': user_email}
            if content_type:
                query['type'] = content_type
            cursor = self.collection.find(query).sort('created_at', -1).limit(limit)
            return await cursor.to_list(length=None)
        except Exception as e:
            logger.error(f"Error retrieving user content: {e}")
            return []

    async def update_content(
        self, 
        content_id: str, 
        updates: Dict[str, Any]
    ) -> bool:
        try:
            updates['updated_at'] = datetime.now()
            result = await self.collection.update_one(
                {'_id': ObjectId(content_id)},
                {'$set': updates}
            )
            return result.modified_count > 0
        except Exception as e:
            logger.error(f"Error updating content: {e}")
            return False

class AsyncFileHandler:
    def __init__(self, fs):
        self.fs = fs

    async def save_file(
        self, 
        filename: str, 
        file_data: bytes, 
        metadata: Dict[str, Any]
    ) -> str:
        try:
            file_id = await self.fs.upload_from_stream(
                filename,
                file_data,
                metadata={
                    **metadata,
                    'uploaded_at': datetime.now()
                }
            )
            return str(file_id)
        except Exception as e:
            logger.error(f"Error saving file: {e}")
            raise

    async def get_file(self, file_id: str) -> Optional[bytes]:
        try:
            grid_out = await self.fs.open_download_stream(ObjectId(file_id))
            return await grid_out.read()
        except Exception as e:
            logger.error(f"Error retrieving file: {e}")
            return None

class AsyncAnalyticsHandler:
    def __init__(self, db):
        self.db = db
        self.collection = db.analytics

    async def log_activity(
        self, 
        user_email: str, 
        activity_type: str, 
        metadata: Dict[str, Any]
    ) -> None:
        try:
            document = {
                'user_email': user_email,
                'activity_type': activity_type,
                'metadata': metadata,
                'timestamp': datetime.now()
            }
            await self.collection.insert_one(document)
        except Exception as e:
            logger.error(f"Error logging activity: {e}")

    async def get_user_analytics(
        self, 
        user_email: str, 
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None
    ) -> List[Dict]:
        try:
            pipeline = [
                {'$match': {
                    'user_email': user_email,
                    **({'timestamp': {
                        '$gte': start_date,
                        '$lte': end_date
                    }} if start_date and end_date else {})
                }},
                {'$group': {
                    '_id': '$activity_type',
                    'count': {'$sum': 1},
                    'last_activity': {'$max': '$timestamp'}
                }}
            ]
            cursor = self.collection.aggregate(pipeline)
            return await cursor.to_list(length=None)
        except Exception as e:
            logger.error(f"Error retrieving analytics: {e}")
            return []

================
File: utils/key_rotation.py
================
# utils/key_rotation.py
import secrets
import jwt
from datetime import datetime, timedelta
import logging
from typing import Optional, Dict, Any

logger = logging.getLogger(__name__)

class JWTKeyRotator:
    def __init__(self, db):
        self.db = db
        self.keys_collection = db.jwt_keys

    async def generate_new_key(self) -> str:
        """Generate a new JWT secret key"""
        return secrets.token_hex(32)

    async def store_key(self, key: str, expiry_days: int = 30) -> str:
        """Store a new JWT key with expiration"""
        try:
            key_doc = {
                'key': key,
                'created_at': datetime.utcnow(),
                'expires_at': datetime.utcnow() + timedelta(days=expiry_days),
                'is_active': True
            }
            result = await self.keys_collection.insert_one(key_doc)
            return str(result.inserted_id)
        except Exception as e:
            logger.error(f"Error storing JWT key: {e}")
            raise

    async def rotate_key(self, expiry_days: int = 30) -> Dict[str, Any]:
        """Generate and store a new key while deprecating the old one"""
        try:
            # Generate new key
            new_key = await self.generate_new_key()
            
            # Store new key
            new_key_id = await self.store_key(new_key, expiry_days)
            
            # Deactivate old keys
            await self.keys_collection.update_many(
                {'_id': {'$ne': new_key_id}},
                {'$set': {'is_active': False}}
            )
            
            return {
                'key_id': new_key_id,
                'key': new_key,
                'expires_at': datetime.utcnow() + timedelta(days=expiry_days)
            }
        except Exception as e:
            logger.error(f"Error rotating JWT key: {e}")
            raise

    async def get_active_key(self) -> Optional[str]:
        """Get the current active JWT key"""
        try:
            key_doc = await self.keys_collection.find_one(
                {
                    'is_active': True,
                    'expires_at': {'$gt': datetime.utcnow()}
                }
            )
            return key_doc['key'] if key_doc else None
        except Exception as e:
            logger.error(f"Error retrieving active JWT key: {e}")
            return None

    async def cleanup_expired_keys(self) -> int:
        """Remove expired keys from the database"""
        try:
            result = await self.keys_collection.delete_many(
                {'expires_at': {'$lt': datetime.utcnow()}}
            )
            return result.deleted_count
        except Exception as e:
            logger.error(f"Error cleaning up expired JWT keys: {e}")
            return 0

================
File: utils/mongo_manager.py
================
# utils/mongo_manager.py
import os
import motor.motor_asyncio
import asyncio
from motor.motor_asyncio import AsyncIOMotorGridFSBucket
import logging
from typing import Tuple, Any

logger = logging.getLogger(__name__)

def ensure_event_loop():
    """Ensure an event loop exists in the current thread"""
    try:
        loop = asyncio.get_event_loop()
    except RuntimeError:
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
    return loop

class AsyncMongoManager:
    def __init__(self):
        self.uri = os.getenv('MONGODB_URI')
        if not self.uri:
            raise ValueError("MONGODB_URI not found in environment variables")

        # Ensure event loop exists
        ensure_event_loop()
        
        # Initialize client
        self.client = motor.motor_asyncio.AsyncIOMotorClient(self.uri)
        self.db = self.client.fairness_factor_blog

    async def get_fs(self):
        """Get GridFS bucket lazily"""
        if not hasattr(self, 'fs'):
            self.fs = AsyncIOMotorGridFSBucket(self.db)
        return self.fs

    async def _ensure_index(self, collection, keys, **kwargs):
        """Safely create an index if it doesn't exist"""
        try:
            # Drop any existing index with the same key pattern
            await collection.drop_index([(k, v) for k, v in keys])
        except:
            # Ignore errors from dropping non-existent indexes
            pass

        try:
            # Create new index
            await collection.create_index([(k, v) for k, v in keys], **kwargs)
        except Exception as e:
            logger.warning(f"Error creating index on {collection.name}: {str(e)}")

    async def initialize(self):
        """Initialize database connection and indexes"""
        try:
            # Test connection
            await self.client.admin.command('ping')
            
            # Create indexes safely
            await self._ensure_index(self.db.users, [('email', 1)], unique=True, name='unique_email')
            await self._ensure_index(self.db.blog_content, [('user_email', 1)], name='blog_user_email')
            await self._ensure_index(self.db.blog_content, [('created_at', -1)], name='blog_created_at')
            await self._ensure_index(self.db.analytics, [('timestamp', -1)], name='analytics_timestamp')

            # Initialize GridFS
            fs = await self.get_fs()
            
            logger.info("Successfully connected to MongoDB and initialized indexes")
            return self.client, self.db, fs
            
        except Exception as e:
            logger.error(f"Failed to initialize MongoDB: {e}")
            await self.close()
            raise

    async def close(self):
        """Close database connection"""
        if hasattr(self, 'client'):
            self.client.close()

class AsyncDatabaseSession:
    def __init__(self):
        self.manager = None

    async def __aenter__(self) -> Tuple[Any, Any, Any]:
        # Create manager and initialize connection
        self.manager = AsyncMongoManager()
        return await self.manager.initialize()

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.manager:
            await self.manager.close()

def get_db_session() -> AsyncDatabaseSession:
    """Get database session"""
    return AsyncDatabaseSession()

================
File: utils/prompt_handler.py
================
# utils/prompt_handler.py
import os
from typing import Optional, Dict, Any
import logging
import json
from datetime import datetime

logger = logging.getLogger(__name__)

class AsyncPromptHandler:
    def __init__(self, db):
        self.db = db
        self.prompts_collection = db.prompts

    async def load_prompt(self, prompt_name: str) -> Optional[str]:
        """Load prompt template from database or file system"""
        try:
            # Try to load from database first
            prompt_doc = await self.prompts_collection.find_one({'name': prompt_name})
            if prompt_doc:
                return prompt_doc['content']

            # Fall back to file system
            prompt_path = f"prompts/{prompt_name}.txt"
            if os.path.exists(prompt_path):
                with open(prompt_path, 'r') as f:
                    content = f.read()
                    # Store in database for future use
                    await self.prompts_collection.insert_one({
                        'name': prompt_name,
                        'content': content,
                        'created_at': datetime.now()
                    })
                    return content
            
            raise FileNotFoundError(f"Prompt template {prompt_name} not found")
            
        except Exception as e:
            logger.error(f"Error loading prompt {prompt_name}: {str(e)}")
            return None

    async def format_prompt(
        self, 
        prompt_name: str, 
        variables: Dict[str, Any]
    ) -> Optional[str]:
        """Load and format prompt template with variables"""
        try:
            template = await self.load_prompt(prompt_name)
            if not template:
                return None

            # Format prompt with variables
            formatted_prompt = template
            for key, value in variables.items():
                formatted_prompt = formatted_prompt.replace(f"{{{key}}}", str(value))

            return formatted_prompt

        except Exception as e:
            logger.error(f"Error formatting prompt {prompt_name}: {str(e)}")
            return None

    async def save_prompt_history(
        self, 
        prompt_name: str, 
        variables: Dict[str, Any], 
        formatted_prompt: str,
        user_email: str
    ) -> Optional[str]:
        """Save prompt usage history"""
        try:
            result = await self.db.prompt_history.insert_one({
                'prompt_name': prompt_name,
                'variables': variables,
                'formatted_prompt': formatted_prompt,
                'user_email': user_email,
                'timestamp': datetime.now()
            })
            return str(result.inserted_id)
        except Exception as e:
            logger.error(f"Error saving prompt history: {str(e)}")
            return None

================
File: utils/session_manager.py
================
# utils/session_manager.py
from datetime import datetime
import logging
from typing import Optional, Dict, Any, List  # Add List to the imports
from motor.motor_asyncio import AsyncIOMotorDatabase
from bson import ObjectId  # Add this import for ObjectId

logger = logging.getLogger(__name__)

class AsyncSessionManager:
    def __init__(self, db: AsyncIOMotorDatabase):
        self.db = db
        self.sessions_collection = db.sessions

    async def create_session(
        self, 
        user_email: str, 
        session_data: Dict[str, Any]
    ) -> Optional[str]:
        try:
            result = await self.sessions_collection.insert_one({
                'user_email': user_email,
                'data': session_data,
                'created_at': datetime.now(),
                'last_accessed': datetime.now(),
                'active': True
            })
            return str(result.inserted_id)
        except Exception as e:
            logger.error(f"Error creating session: {str(e)}")
            return None

    async def update_session(
        self, 
        session_id: str, 
        session_data: Dict[str, Any]
    ) -> bool:
        try:
            result = await self.sessions_collection.update_one(
                {'_id': ObjectId(session_id)},
                {
                    '$set': {
                        'data': session_data,
                        'last_accessed': datetime.now()
                    }
                }
            )
            return result.modified_count > 0
        except Exception as e:
            logger.error(f"Error updating session: {str(e)}")
            return False

    async def end_session(self, session_id: str) -> bool:
        try:
            result = await self.sessions_collection.update_one(
                {'_id': ObjectId(session_id)},
                {
                    '$set': {
                        'active': False,
                        'ended_at': datetime.now()
                    }
                }
            )
            return result.modified_count > 0
        except Exception as e:
            logger.error(f"Error ending session: {str(e)}")
            return False

    async def get_active_sessions(self, user_email: str) -> List[Dict[str, Any]]:
        try:
            cursor = self.sessions_collection.find({
                'user_email': user_email,
                'active': True
            }).sort('last_accessed', -1)
            return await cursor.to_list(length=None)
        except Exception as e:
            logger.error(f"Error retrieving active sessions: {str(e)}")
            return []
